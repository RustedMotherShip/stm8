                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.3.0 #14184 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _i2c_scan
                                     13 	.globl _i2c_stop
                                     14 	.globl _i2c_send_address
                                     15 	.globl _i2c_start
                                     16 	.globl _i2c_init
                                     17 	.globl _uart_init
                                     18 	.globl _status_check
                                     19 	.globl _convert_int_to_binary
                                     20 	.globl _convert_int_to_chars
                                     21 	.globl _uart_write
                                     22 	.globl _delay
                                     23 	.globl _strlen
                                     24 ;--------------------------------------------------------
                                     25 ; ram data
                                     26 ;--------------------------------------------------------
                                     27 	.area DATA
                                     28 ;--------------------------------------------------------
                                     29 ; ram data
                                     30 ;--------------------------------------------------------
                                     31 	.area INITIALIZED
                                     32 ;--------------------------------------------------------
                                     33 ; Stack segment in internal ram
                                     34 ;--------------------------------------------------------
                                     35 	.area SSEG
      000000                         36 __start__stack:
      000000                         37 	.ds	1
                                     38 
                                     39 ;--------------------------------------------------------
                                     40 ; absolute external ram data
                                     41 ;--------------------------------------------------------
                                     42 	.area DABS (ABS)
                                     43 
                                     44 ; default segment ordering for linker
                                     45 	.area HOME
                                     46 	.area GSINIT
                                     47 	.area GSFINAL
                                     48 	.area CONST
                                     49 	.area INITIALIZER
                                     50 	.area CODE
                                     51 
                                     52 ;--------------------------------------------------------
                                     53 ; interrupt vector
                                     54 ;--------------------------------------------------------
                                     55 	.area HOME
      000000                         56 __interrupt_vect:
      000000 82v00u00u00             57 	int s_GSINIT ; reset
                                     58 ;--------------------------------------------------------
                                     59 ; global & static initialisations
                                     60 ;--------------------------------------------------------
                                     61 	.area HOME
                                     62 	.area GSINIT
                                     63 	.area GSFINAL
                                     64 	.area GSINIT
      000000 CDr00r00         [ 4]   65 	call	___sdcc_external_startup
      000003 4D               [ 1]   66 	tnz	a
      000004 27 03            [ 1]   67 	jreq	__sdcc_init_data
      000006 CCr00r04         [ 2]   68 	jp	__sdcc_program_startup
      000009                         69 __sdcc_init_data:
                                     70 ; stm8_genXINIT() start
      000009 AEr00r00         [ 2]   71 	ldw x, #l_DATA
      00000C 27 07            [ 1]   72 	jreq	00002$
      00000E                         73 00001$:
      00000E 72 4FuFFuFF      [ 1]   74 	clr (s_DATA - 1, x)
      000012 5A               [ 2]   75 	decw x
      000013 26 F9            [ 1]   76 	jrne	00001$
      000015                         77 00002$:
      000015 AEr00r00         [ 2]   78 	ldw	x, #l_INITIALIZER
      000018 27 09            [ 1]   79 	jreq	00004$
      00001A                         80 00003$:
      00001A D6uFFuFF         [ 1]   81 	ld	a, (s_INITIALIZER - 1, x)
      00001D D7uFFuFF         [ 1]   82 	ld	(s_INITIALIZED - 1, x), a
      000020 5A               [ 2]   83 	decw	x
      000021 26 F7            [ 1]   84 	jrne	00003$
      000023                         85 00004$:
                                     86 ; stm8_genXINIT() end
                                     87 	.area GSFINAL
      000000 CCr00r04         [ 2]   88 	jp	__sdcc_program_startup
                                     89 ;--------------------------------------------------------
                                     90 ; Home
                                     91 ;--------------------------------------------------------
                                     92 	.area HOME
                                     93 	.area HOME
      000004                         94 __sdcc_program_startup:
      000004 CCr02rA3         [ 2]   95 	jp	_main
                                     96 ;	return from main will return to caller
                                     97 ;--------------------------------------------------------
                                     98 ; code
                                     99 ;--------------------------------------------------------
                                    100 	.area CODE
                                    101 ;	main.c: 7: void delay(unsigned long count) {
                                    102 ;	-----------------------------------------
                                    103 ;	 function delay
                                    104 ;	-----------------------------------------
      000000                        105 _delay:
      000000 52 08            [ 2]  106 	sub	sp, #8
                                    107 ;	main.c: 8: while (count--)
      000002 16 0D            [ 2]  108 	ldw	y, (0x0d, sp)
      000004 17 07            [ 2]  109 	ldw	(0x07, sp), y
      000006 1E 0B            [ 2]  110 	ldw	x, (0x0b, sp)
      000008                        111 00101$:
      000008 1F 01            [ 2]  112 	ldw	(0x01, sp), x
      00000A 7B 07            [ 1]  113 	ld	a, (0x07, sp)
      00000C 6B 03            [ 1]  114 	ld	(0x03, sp), a
      00000E 7B 08            [ 1]  115 	ld	a, (0x08, sp)
      000010 16 07            [ 2]  116 	ldw	y, (0x07, sp)
      000012 72 A2 00 01      [ 2]  117 	subw	y, #0x0001
      000016 17 07            [ 2]  118 	ldw	(0x07, sp), y
      000018 24 01            [ 1]  119 	jrnc	00117$
      00001A 5A               [ 2]  120 	decw	x
      00001B                        121 00117$:
      00001B 4D               [ 1]  122 	tnz	a
      00001C 26 08            [ 1]  123 	jrne	00118$
      00001E 16 02            [ 2]  124 	ldw	y, (0x02, sp)
      000020 26 04            [ 1]  125 	jrne	00118$
      000022 0D 01            [ 1]  126 	tnz	(0x01, sp)
      000024 27 03            [ 1]  127 	jreq	00104$
      000026                        128 00118$:
                                    129 ;	main.c: 9: nop();
      000026 9D               [ 1]  130 	nop
      000027 20 DF            [ 2]  131 	jra	00101$
      000029                        132 00104$:
                                    133 ;	main.c: 10: }
      000029 1E 09            [ 2]  134 	ldw	x, (9, sp)
      00002B 5B 0E            [ 2]  135 	addw	sp, #14
      00002D FC               [ 2]  136 	jp	(x)
                                    137 ;	main.c: 12: int uart_write(const char *str) {
                                    138 ;	-----------------------------------------
                                    139 ;	 function uart_write
                                    140 ;	-----------------------------------------
      00002E                        141 _uart_write:
      00002E 52 05            [ 2]  142 	sub	sp, #5
      000030 1F 03            [ 2]  143 	ldw	(0x03, sp), x
                                    144 ;	main.c: 14: for(i = 0; i < strlen(str); i++) {
      000032 0F 05            [ 1]  145 	clr	(0x05, sp)
      000034                        146 00106$:
      000034 1E 03            [ 2]  147 	ldw	x, (0x03, sp)
      000036 CDr00r00         [ 4]  148 	call	_strlen
      000039 1F 01            [ 2]  149 	ldw	(0x01, sp), x
      00003B 5F               [ 1]  150 	clrw	x
      00003C 7B 05            [ 1]  151 	ld	a, (0x05, sp)
      00003E 97               [ 1]  152 	ld	xl, a
      00003F 13 01            [ 2]  153 	cpw	x, (0x01, sp)
      000041 24 14            [ 1]  154 	jrnc	00104$
                                    155 ;	main.c: 15: while(!(UART1_SR & UART_SR_TXE)); // !Transmit data register empty
      000043                        156 00101$:
      000043 C6 52 30         [ 1]  157 	ld	a, 0x5230
      000046 2A FB            [ 1]  158 	jrpl	00101$
                                    159 ;	main.c: 16: UART1_DR = str[i];
      000048 5F               [ 1]  160 	clrw	x
      000049 7B 05            [ 1]  161 	ld	a, (0x05, sp)
      00004B 97               [ 1]  162 	ld	xl, a
      00004C 72 FB 03         [ 2]  163 	addw	x, (0x03, sp)
      00004F F6               [ 1]  164 	ld	a, (x)
      000050 C7 52 31         [ 1]  165 	ld	0x5231, a
                                    166 ;	main.c: 14: for(i = 0; i < strlen(str); i++) {
      000053 0C 05            [ 1]  167 	inc	(0x05, sp)
      000055 20 DD            [ 2]  168 	jra	00106$
      000057                        169 00104$:
                                    170 ;	main.c: 18: return(i); // Bytes sent
      000057 7B 05            [ 1]  171 	ld	a, (0x05, sp)
      000059 5F               [ 1]  172 	clrw	x
      00005A 97               [ 1]  173 	ld	xl, a
                                    174 ;	main.c: 19: }
      00005B 5B 05            [ 2]  175 	addw	sp, #5
      00005D 81               [ 4]  176 	ret
                                    177 ;	main.c: 21: void convert_int_to_chars(uint8_t num, char* rx_int_chars) {
                                    178 ;	-----------------------------------------
                                    179 ;	 function convert_int_to_chars
                                    180 ;	-----------------------------------------
      00005E                        181 _convert_int_to_chars:
      00005E 52 0D            [ 2]  182 	sub	sp, #13
      000060 6B 0D            [ 1]  183 	ld	(0x0d, sp), a
      000062 1F 0B            [ 2]  184 	ldw	(0x0b, sp), x
                                    185 ;	main.c: 24: rx_int_chars[0] = num / 100 + '0';
      000064 7B 0D            [ 1]  186 	ld	a, (0x0d, sp)
      000066 6B 02            [ 1]  187 	ld	(0x02, sp), a
      000068 0F 01            [ 1]  188 	clr	(0x01, sp)
                                    189 ;	main.c: 25: rx_int_chars[1] = num / 10 % 10 + '0';
      00006A 1E 0B            [ 2]  190 	ldw	x, (0x0b, sp)
      00006C 5C               [ 1]  191 	incw	x
      00006D 1F 03            [ 2]  192 	ldw	(0x03, sp), x
                                    193 ;	main.c: 26: rx_int_chars[2] = num % 10 + '0';
      00006F 1E 0B            [ 2]  194 	ldw	x, (0x0b, sp)
      000071 5C               [ 1]  195 	incw	x
      000072 5C               [ 1]  196 	incw	x
      000073 1F 05            [ 2]  197 	ldw	(0x05, sp), x
                                    198 ;	main.c: 25: rx_int_chars[1] = num / 10 % 10 + '0';
      000075 4B 0A            [ 1]  199 	push	#0x0a
      000077 4B 00            [ 1]  200 	push	#0x00
      000079 1E 03            [ 2]  201 	ldw	x, (0x03, sp)
                                    202 ;	main.c: 26: rx_int_chars[2] = num % 10 + '0';
      00007B CDr00r00         [ 4]  203 	call	__divsint
      00007E 1F 07            [ 2]  204 	ldw	(0x07, sp), x
      000080 4B 0A            [ 1]  205 	push	#0x0a
      000082 4B 00            [ 1]  206 	push	#0x00
      000084 1E 03            [ 2]  207 	ldw	x, (0x03, sp)
      000086 CDr00r00         [ 4]  208 	call	__modsint
      000089 9F               [ 1]  209 	ld	a, xl
      00008A AB 30            [ 1]  210 	add	a, #0x30
      00008C 6B 09            [ 1]  211 	ld	(0x09, sp), a
                                    212 ;	main.c: 22: if (num > 99) {
      00008E 7B 0D            [ 1]  213 	ld	a, (0x0d, sp)
      000090 A1 63            [ 1]  214 	cp	a, #0x63
      000092 23 29            [ 2]  215 	jrule	00105$
                                    216 ;	main.c: 24: rx_int_chars[0] = num / 100 + '0';
      000094 4B 64            [ 1]  217 	push	#0x64
      000096 4B 00            [ 1]  218 	push	#0x00
      000098 1E 03            [ 2]  219 	ldw	x, (0x03, sp)
      00009A CDr00r00         [ 4]  220 	call	__divsint
      00009D 9F               [ 1]  221 	ld	a, xl
      00009E AB 30            [ 1]  222 	add	a, #0x30
      0000A0 1E 0B            [ 2]  223 	ldw	x, (0x0b, sp)
      0000A2 F7               [ 1]  224 	ld	(x), a
                                    225 ;	main.c: 25: rx_int_chars[1] = num / 10 % 10 + '0';
      0000A3 4B 0A            [ 1]  226 	push	#0x0a
      0000A5 4B 00            [ 1]  227 	push	#0x00
      0000A7 1E 09            [ 2]  228 	ldw	x, (0x09, sp)
      0000A9 CDr00r00         [ 4]  229 	call	__modsint
      0000AC 9F               [ 1]  230 	ld	a, xl
      0000AD AB 30            [ 1]  231 	add	a, #0x30
      0000AF 1E 03            [ 2]  232 	ldw	x, (0x03, sp)
      0000B1 F7               [ 1]  233 	ld	(x), a
                                    234 ;	main.c: 26: rx_int_chars[2] = num % 10 + '0';
      0000B2 1E 05            [ 2]  235 	ldw	x, (0x05, sp)
      0000B4 7B 09            [ 1]  236 	ld	a, (0x09, sp)
      0000B6 F7               [ 1]  237 	ld	(x), a
                                    238 ;	main.c: 27: rx_int_chars[3] ='\0';
      0000B7 1E 0B            [ 2]  239 	ldw	x, (0x0b, sp)
      0000B9 6F 03            [ 1]  240 	clr	(0x0003, x)
      0000BB 20 23            [ 2]  241 	jra	00107$
      0000BD                        242 00105$:
                                    243 ;	main.c: 29: } else if (num > 9) {
      0000BD 7B 0D            [ 1]  244 	ld	a, (0x0d, sp)
      0000BF A1 09            [ 1]  245 	cp	a, #0x09
      0000C1 23 13            [ 2]  246 	jrule	00102$
                                    247 ;	main.c: 31: rx_int_chars[0] = num / 10 + '0';
      0000C3 7B 08            [ 1]  248 	ld	a, (0x08, sp)
      0000C5 6B 0A            [ 1]  249 	ld	(0x0a, sp), a
      0000C7 AB 30            [ 1]  250 	add	a, #0x30
      0000C9 1E 0B            [ 2]  251 	ldw	x, (0x0b, sp)
      0000CB F7               [ 1]  252 	ld	(x), a
                                    253 ;	main.c: 32: rx_int_chars[1] = num % 10 + '0';
      0000CC 1E 03            [ 2]  254 	ldw	x, (0x03, sp)
      0000CE 7B 09            [ 1]  255 	ld	a, (0x09, sp)
      0000D0 F7               [ 1]  256 	ld	(x), a
                                    257 ;	main.c: 33: rx_int_chars[2] ='\0';
      0000D1 1E 05            [ 2]  258 	ldw	x, (0x05, sp)
      0000D3 7F               [ 1]  259 	clr	(x)
      0000D4 20 0A            [ 2]  260 	jra	00107$
      0000D6                        261 00102$:
                                    262 ;	main.c: 38: rx_int_chars[0] = num + '0';
      0000D6 7B 0D            [ 1]  263 	ld	a, (0x0d, sp)
      0000D8 AB 30            [ 1]  264 	add	a, #0x30
      0000DA 1E 0B            [ 2]  265 	ldw	x, (0x0b, sp)
      0000DC F7               [ 1]  266 	ld	(x), a
                                    267 ;	main.c: 39: rx_int_chars[1] ='\0';
      0000DD 1E 03            [ 2]  268 	ldw	x, (0x03, sp)
      0000DF 7F               [ 1]  269 	clr	(x)
      0000E0                        270 00107$:
                                    271 ;	main.c: 41: }
      0000E0 5B 0D            [ 2]  272 	addw	sp, #13
      0000E2 81               [ 4]  273 	ret
                                    274 ;	main.c: 43: void convert_int_to_binary(int num, char* rx_binary_chars) {
                                    275 ;	-----------------------------------------
                                    276 ;	 function convert_int_to_binary
                                    277 ;	-----------------------------------------
      0000E3                        278 _convert_int_to_binary:
      0000E3 52 04            [ 2]  279 	sub	sp, #4
      0000E5 1F 01            [ 2]  280 	ldw	(0x01, sp), x
                                    281 ;	main.c: 45: for(int i = 7; i >= 0; i--) {
      0000E7 AE 00 07         [ 2]  282 	ldw	x, #0x0007
      0000EA 1F 03            [ 2]  283 	ldw	(0x03, sp), x
      0000EC                        284 00103$:
      0000EC 0D 03            [ 1]  285 	tnz	(0x03, sp)
      0000EE 2B 22            [ 1]  286 	jrmi	00101$
                                    287 ;	main.c: 47: rx_binary_chars[7 - i] = ((num >> i) & 1) + '0';
      0000F0 AE 00 07         [ 2]  288 	ldw	x, #0x0007
      0000F3 72 F0 03         [ 2]  289 	subw	x, (0x03, sp)
      0000F6 72 FB 07         [ 2]  290 	addw	x, (0x07, sp)
      0000F9 16 01            [ 2]  291 	ldw	y, (0x01, sp)
      0000FB 7B 04            [ 1]  292 	ld	a, (0x04, sp)
      0000FD 27 05            [ 1]  293 	jreq	00120$
      0000FF                        294 00119$:
      0000FF 90 57            [ 2]  295 	sraw	y
      000101 4A               [ 1]  296 	dec	a
      000102 26 FB            [ 1]  297 	jrne	00119$
      000104                        298 00120$:
      000104 90 9F            [ 1]  299 	ld	a, yl
      000106 A4 01            [ 1]  300 	and	a, #0x01
      000108 AB 30            [ 1]  301 	add	a, #0x30
      00010A F7               [ 1]  302 	ld	(x), a
                                    303 ;	main.c: 45: for(int i = 7; i >= 0; i--) {
      00010B 1E 03            [ 2]  304 	ldw	x, (0x03, sp)
      00010D 5A               [ 2]  305 	decw	x
      00010E 1F 03            [ 2]  306 	ldw	(0x03, sp), x
      000110 20 DA            [ 2]  307 	jra	00103$
      000112                        308 00101$:
                                    309 ;	main.c: 49: rx_binary_chars[8] = '\0'; // Добавляем символ конца строки
      000112 1E 07            [ 2]  310 	ldw	x, (0x07, sp)
      000114 6F 08            [ 1]  311 	clr	(0x0008, x)
                                    312 ;	main.c: 50: }
      000116 1E 05            [ 2]  313 	ldw	x, (5, sp)
      000118 5B 08            [ 2]  314 	addw	sp, #8
      00011A FC               [ 2]  315 	jp	(x)
                                    316 ;	main.c: 52: void status_check(void){
                                    317 ;	-----------------------------------------
                                    318 ;	 function status_check
                                    319 ;	-----------------------------------------
      00011B                        320 _status_check:
      00011B 52 09            [ 2]  321 	sub	sp, #9
                                    322 ;	main.c: 53: char rx_binary_chars[9]={0};
      00011D 0F 01            [ 1]  323 	clr	(0x01, sp)
      00011F 0F 02            [ 1]  324 	clr	(0x02, sp)
      000121 0F 03            [ 1]  325 	clr	(0x03, sp)
      000123 0F 04            [ 1]  326 	clr	(0x04, sp)
      000125 0F 05            [ 1]  327 	clr	(0x05, sp)
      000127 0F 06            [ 1]  328 	clr	(0x06, sp)
      000129 0F 07            [ 1]  329 	clr	(0x07, sp)
      00012B 0F 08            [ 1]  330 	clr	(0x08, sp)
      00012D 0F 09            [ 1]  331 	clr	(0x09, sp)
                                    332 ;	main.c: 54: convert_int_to_binary(I2C_SR1, rx_binary_chars);
      00012F 96               [ 1]  333 	ldw	x, sp
      000130 5C               [ 1]  334 	incw	x
      000131 51               [ 1]  335 	exgw	x, y
      000132 C6 52 17         [ 1]  336 	ld	a, 0x5217
      000135 5F               [ 1]  337 	clrw	x
      000136 90 89            [ 2]  338 	pushw	y
      000138 97               [ 1]  339 	ld	xl, a
      000139 CDr00rE3         [ 4]  340 	call	_convert_int_to_binary
                                    341 ;	main.c: 55: uart_write("\nSR1 -> ");
      00013C AEr00r00         [ 2]  342 	ldw	x, #(___str_0+0)
      00013F CDr00r2E         [ 4]  343 	call	_uart_write
                                    344 ;	main.c: 56: uart_write(rx_binary_chars);
      000142 96               [ 1]  345 	ldw	x, sp
      000143 5C               [ 1]  346 	incw	x
      000144 CDr00r2E         [ 4]  347 	call	_uart_write
                                    348 ;	main.c: 57: uart_write(" <-\n");
      000147 AEr00r09         [ 2]  349 	ldw	x, #(___str_1+0)
      00014A CDr00r2E         [ 4]  350 	call	_uart_write
                                    351 ;	main.c: 58: convert_int_to_binary(I2C_SR2, rx_binary_chars);
      00014D 96               [ 1]  352 	ldw	x, sp
      00014E 5C               [ 1]  353 	incw	x
      00014F 51               [ 1]  354 	exgw	x, y
      000150 C6 52 18         [ 1]  355 	ld	a, 0x5218
      000153 5F               [ 1]  356 	clrw	x
      000154 90 89            [ 2]  357 	pushw	y
      000156 97               [ 1]  358 	ld	xl, a
      000157 CDr00rE3         [ 4]  359 	call	_convert_int_to_binary
                                    360 ;	main.c: 59: uart_write("SR2 -> ");
      00015A AEr00r0E         [ 2]  361 	ldw	x, #(___str_2+0)
      00015D CDr00r2E         [ 4]  362 	call	_uart_write
                                    363 ;	main.c: 60: uart_write(rx_binary_chars);
      000160 96               [ 1]  364 	ldw	x, sp
      000161 5C               [ 1]  365 	incw	x
      000162 CDr00r2E         [ 4]  366 	call	_uart_write
                                    367 ;	main.c: 61: uart_write(" <-\n");
      000165 AEr00r09         [ 2]  368 	ldw	x, #(___str_1+0)
      000168 CDr00r2E         [ 4]  369 	call	_uart_write
                                    370 ;	main.c: 62: convert_int_to_binary(I2C_SR3, rx_binary_chars);
      00016B 96               [ 1]  371 	ldw	x, sp
      00016C 5C               [ 1]  372 	incw	x
      00016D 51               [ 1]  373 	exgw	x, y
      00016E C6 52 19         [ 1]  374 	ld	a, 0x5219
      000171 5F               [ 1]  375 	clrw	x
      000172 90 89            [ 2]  376 	pushw	y
      000174 97               [ 1]  377 	ld	xl, a
      000175 CDr00rE3         [ 4]  378 	call	_convert_int_to_binary
                                    379 ;	main.c: 63: uart_write("SR3 -> ");
      000178 AEr00r16         [ 2]  380 	ldw	x, #(___str_3+0)
      00017B CDr00r2E         [ 4]  381 	call	_uart_write
                                    382 ;	main.c: 64: uart_write(rx_binary_chars);
      00017E 96               [ 1]  383 	ldw	x, sp
      00017F 5C               [ 1]  384 	incw	x
      000180 CDr00r2E         [ 4]  385 	call	_uart_write
                                    386 ;	main.c: 65: uart_write(" <-\n");
      000183 AEr00r09         [ 2]  387 	ldw	x, #(___str_1+0)
      000186 CDr00r2E         [ 4]  388 	call	_uart_write
                                    389 ;	main.c: 66: convert_int_to_binary(I2C_CR1, rx_binary_chars);
      000189 96               [ 1]  390 	ldw	x, sp
      00018A 5C               [ 1]  391 	incw	x
      00018B 51               [ 1]  392 	exgw	x, y
      00018C C6 52 10         [ 1]  393 	ld	a, 0x5210
      00018F 5F               [ 1]  394 	clrw	x
      000190 90 89            [ 2]  395 	pushw	y
      000192 97               [ 1]  396 	ld	xl, a
      000193 CDr00rE3         [ 4]  397 	call	_convert_int_to_binary
                                    398 ;	main.c: 67: uart_write("CR1 -> ");
      000196 AEr00r1E         [ 2]  399 	ldw	x, #(___str_4+0)
      000199 CDr00r2E         [ 4]  400 	call	_uart_write
                                    401 ;	main.c: 68: uart_write(rx_binary_chars);
      00019C 96               [ 1]  402 	ldw	x, sp
      00019D 5C               [ 1]  403 	incw	x
      00019E CDr00r2E         [ 4]  404 	call	_uart_write
                                    405 ;	main.c: 69: uart_write(" <-\n");
      0001A1 AEr00r09         [ 2]  406 	ldw	x, #(___str_1+0)
      0001A4 CDr00r2E         [ 4]  407 	call	_uart_write
                                    408 ;	main.c: 70: convert_int_to_binary(I2C_CR2, rx_binary_chars);
      0001A7 96               [ 1]  409 	ldw	x, sp
      0001A8 5C               [ 1]  410 	incw	x
      0001A9 51               [ 1]  411 	exgw	x, y
      0001AA C6 52 11         [ 1]  412 	ld	a, 0x5211
      0001AD 5F               [ 1]  413 	clrw	x
      0001AE 90 89            [ 2]  414 	pushw	y
      0001B0 97               [ 1]  415 	ld	xl, a
      0001B1 CDr00rE3         [ 4]  416 	call	_convert_int_to_binary
                                    417 ;	main.c: 71: uart_write("CR2 -> ");
      0001B4 AEr00r26         [ 2]  418 	ldw	x, #(___str_5+0)
      0001B7 CDr00r2E         [ 4]  419 	call	_uart_write
                                    420 ;	main.c: 72: uart_write(rx_binary_chars);
      0001BA 96               [ 1]  421 	ldw	x, sp
      0001BB 5C               [ 1]  422 	incw	x
      0001BC CDr00r2E         [ 4]  423 	call	_uart_write
                                    424 ;	main.c: 73: uart_write(" <-\n");
      0001BF AEr00r09         [ 2]  425 	ldw	x, #(___str_1+0)
      0001C2 CDr00r2E         [ 4]  426 	call	_uart_write
                                    427 ;	main.c: 74: convert_int_to_binary(I2C_DR, rx_binary_chars);
      0001C5 96               [ 1]  428 	ldw	x, sp
      0001C6 5C               [ 1]  429 	incw	x
      0001C7 51               [ 1]  430 	exgw	x, y
      0001C8 C6 52 16         [ 1]  431 	ld	a, 0x5216
      0001CB 5F               [ 1]  432 	clrw	x
      0001CC 90 89            [ 2]  433 	pushw	y
      0001CE 97               [ 1]  434 	ld	xl, a
      0001CF CDr00rE3         [ 4]  435 	call	_convert_int_to_binary
                                    436 ;	main.c: 75: uart_write("DR -> ");
      0001D2 AEr00r2E         [ 2]  437 	ldw	x, #(___str_6+0)
      0001D5 CDr00r2E         [ 4]  438 	call	_uart_write
                                    439 ;	main.c: 76: uart_write(rx_binary_chars);
      0001D8 96               [ 1]  440 	ldw	x, sp
      0001D9 5C               [ 1]  441 	incw	x
      0001DA CDr00r2E         [ 4]  442 	call	_uart_write
                                    443 ;	main.c: 77: uart_write(" <-\n");
      0001DD AEr00r09         [ 2]  444 	ldw	x, #(___str_1+0)
      0001E0 CDr00r2E         [ 4]  445 	call	_uart_write
                                    446 ;	main.c: 78: }
      0001E3 5B 09            [ 2]  447 	addw	sp, #9
      0001E5 81               [ 4]  448 	ret
                                    449 ;	main.c: 80: void uart_init(void){
                                    450 ;	-----------------------------------------
                                    451 ;	 function uart_init
                                    452 ;	-----------------------------------------
      0001E6                        453 _uart_init:
                                    454 ;	main.c: 81: CLK_CKDIVR = 0;
      0001E6 35 00 50 C6      [ 1]  455 	mov	0x50c6+0, #0x00
                                    456 ;	main.c: 84: UART1_CR2 |= UART_CR2_TEN; // Transmitter enable
      0001EA 72 16 52 35      [ 1]  457 	bset	0x5235, #3
                                    458 ;	main.c: 86: UART1_CR3 &= ~(UART_CR3_STOP1 | UART_CR3_STOP2); // 1 stop bit
      0001EE C6 52 36         [ 1]  459 	ld	a, 0x5236
      0001F1 A4 CF            [ 1]  460 	and	a, #0xcf
      0001F3 C7 52 36         [ 1]  461 	ld	0x5236, a
                                    462 ;	main.c: 88: UART1_BRR2 = 0x03; UART1_BRR1 = 0x68; // 0x0683 coded funky way (see ref manual)
      0001F6 35 03 52 33      [ 1]  463 	mov	0x5233+0, #0x03
      0001FA 35 68 52 32      [ 1]  464 	mov	0x5232+0, #0x68
                                    465 ;	main.c: 89: }
      0001FE 81               [ 4]  466 	ret
                                    467 ;	main.c: 93: void i2c_init(void) {
                                    468 ;	-----------------------------------------
                                    469 ;	 function i2c_init
                                    470 ;	-----------------------------------------
      0001FF                        471 _i2c_init:
                                    472 ;	main.c: 99: I2C_CR1 = I2C_CR1 & ~0x01;      // PE=0, disable I2C before setup
      0001FF 72 11 52 10      [ 1]  473 	bres	0x5210, #0
                                    474 ;	main.c: 100: I2C_FREQR= 16;                  // peripheral frequence =16MHz
      000203 35 10 52 12      [ 1]  475 	mov	0x5212+0, #0x10
                                    476 ;	main.c: 101: I2C_CCRH = 0;                   // =0
      000207 35 00 52 1C      [ 1]  477 	mov	0x521c+0, #0x00
                                    478 ;	main.c: 102: I2C_CCRL = 80;                  // 100kHz for I2C
      00020B 35 50 52 1B      [ 1]  479 	mov	0x521b+0, #0x50
                                    480 ;	main.c: 103: I2C_CCRH = I2C_CCRH & ~0x80;    // set standart mode(100кHz)
      00020F 72 1F 52 1C      [ 1]  481 	bres	0x521c, #7
                                    482 ;	main.c: 104: I2C_OARH = I2C_OARH & ~0x80;    // 7-bit address mode
      000213 72 1F 52 14      [ 1]  483 	bres	0x5214, #7
                                    484 ;	main.c: 105: I2C_OARH = I2C_OARH | 0x40;     // see reference manual
      000217 72 1C 52 14      [ 1]  485 	bset	0x5214, #6
                                    486 ;	main.c: 106: I2C_CR1 = I2C_CR1 | 0x01;       // PE=1, enable I2C
      00021B 72 10 52 10      [ 1]  487 	bset	0x5210, #0
                                    488 ;	main.c: 107: }
      00021F 81               [ 4]  489 	ret
                                    490 ;	main.c: 111: void i2c_start(void) {
                                    491 ;	-----------------------------------------
                                    492 ;	 function i2c_start
                                    493 ;	-----------------------------------------
      000220                        494 _i2c_start:
                                    495 ;	main.c: 112: I2C_CR2 = I2C_CR2 | (1 << 0); // Отправляем стартовый сигнал
      000220 72 10 52 11      [ 1]  496 	bset	0x5211, #0
                                    497 ;	main.c: 113: while(!(I2C_SR1 & (1 << 0)));
      000224                        498 00101$:
      000224 C6 52 17         [ 1]  499 	ld	a, 0x5217
      000227 44               [ 1]  500 	srl	a
      000228 24 FA            [ 1]  501 	jrnc	00101$
                                    502 ;	main.c: 114: uart_write("Start generated\n"); // Ожидание отправки стартового сигнала
      00022A AEr00r35         [ 2]  503 	ldw	x, #(___str_7+0)
                                    504 ;	main.c: 115: }
      00022D CCr00r2E         [ 2]  505 	jp	_uart_write
                                    506 ;	main.c: 117: void i2c_send_address(uint8_t address) {
                                    507 ;	-----------------------------------------
                                    508 ;	 function i2c_send_address
                                    509 ;	-----------------------------------------
      000230                        510 _i2c_send_address:
                                    511 ;	main.c: 118: I2C_DR = address << 1; // Отправка адреса устройства с битом на запись
      000230 48               [ 1]  512 	sll	a
      000231 C7 52 16         [ 1]  513 	ld	0x5216, a
                                    514 ;	main.c: 119: while (!(I2C_SR1 & (1 << 1)) && !(I2C_SR2 & (1 << 2)));
      000234                        515 00102$:
      000234 C6 52 17         [ 1]  516 	ld	a, 0x5217
      000237 A5 02            [ 1]  517 	bcp	a, #0x02
      000239 26 07            [ 1]  518 	jrne	00104$
      00023B C6 52 18         [ 1]  519 	ld	a, 0x5218
      00023E A5 04            [ 1]  520 	bcp	a, #0x04
      000240 27 F2            [ 1]  521 	jreq	00102$
      000242                        522 00104$:
                                    523 ;	main.c: 125: uart_write("Addr send\n"); // Ожидание подтверждения адреса
      000242 AEr00r46         [ 2]  524 	ldw	x, #(___str_8+0)
                                    525 ;	main.c: 126: }
      000245 CCr00r2E         [ 2]  526 	jp	_uart_write
                                    527 ;	main.c: 128: void i2c_stop(void) {
                                    528 ;	-----------------------------------------
                                    529 ;	 function i2c_stop
                                    530 ;	-----------------------------------------
      000248                        531 _i2c_stop:
                                    532 ;	main.c: 129: I2C_CR2 = I2C_CR2 | (1 << 1); // Отправка стопового сигнала
      000248 C6 52 11         [ 1]  533 	ld	a, 0x5211
      00024B AA 02            [ 1]  534 	or	a, #0x02
      00024D C7 52 11         [ 1]  535 	ld	0x5211, a
                                    536 ;	main.c: 130: uart_write("Stop generated\n");
      000250 AEr00r51         [ 2]  537 	ldw	x, #(___str_9+0)
                                    538 ;	main.c: 131: }
      000253 CCr00r2E         [ 2]  539 	jp	_uart_write
                                    540 ;	main.c: 133: void i2c_scan(void) {
                                    541 ;	-----------------------------------------
                                    542 ;	 function i2c_scan
                                    543 ;	-----------------------------------------
      000256                        544 _i2c_scan:
      000256 52 05            [ 2]  545 	sub	sp, #5
                                    546 ;	main.c: 134: for (uint8_t addr = 1; addr < 127; addr++) {
      000258 A6 01            [ 1]  547 	ld	a, #0x01
      00025A 6B 05            [ 1]  548 	ld	(0x05, sp), a
      00025C                        549 00105$:
      00025C 7B 05            [ 1]  550 	ld	a, (0x05, sp)
      00025E A1 7F            [ 1]  551 	cp	a, #0x7f
      000260 24 38            [ 1]  552 	jrnc	00103$
                                    553 ;	main.c: 135: i2c_start();
      000262 CDr02r20         [ 4]  554 	call	_i2c_start
                                    555 ;	main.c: 136: i2c_send_address(addr);
      000265 7B 05            [ 1]  556 	ld	a, (0x05, sp)
      000267 CDr02r30         [ 4]  557 	call	_i2c_send_address
                                    558 ;	main.c: 137: if (!(I2C_SR2 & (1 << 2))) { // Проверка на ACK
      00026A 72 04 52 18 17   [ 2]  559 	btjt	0x5218, #2, 00102$
                                    560 ;	main.c: 139: uart_write("Device found at: ");
      00026F AEr00r61         [ 2]  561 	ldw	x, #(___str_10+0)
      000272 CDr00r2E         [ 4]  562 	call	_uart_write
                                    563 ;	main.c: 140: char rx_int_chars[4]={0};
      000275 0F 01            [ 1]  564 	clr	(0x01, sp)
      000277 0F 02            [ 1]  565 	clr	(0x02, sp)
      000279 0F 03            [ 1]  566 	clr	(0x03, sp)
      00027B 0F 04            [ 1]  567 	clr	(0x04, sp)
                                    568 ;	main.c: 143: uart_write("\r\n");
      00027D AEr00r73         [ 2]  569 	ldw	x, #(___str_11+0)
      000280 CDr00r2E         [ 4]  570 	call	_uart_write
                                    571 ;	main.c: 144: status_check();
      000283 CDr01r1B         [ 4]  572 	call	_status_check
      000286                        573 00102$:
                                    574 ;	main.c: 146: i2c_stop();
      000286 CDr02r48         [ 4]  575 	call	_i2c_stop
                                    576 ;	main.c: 147: I2C_SR2 = I2C_SR2 & ~(1 << 2); // Очистка флага ошибки
      000289 72 15 52 18      [ 1]  577 	bres	0x5218, #2
                                    578 ;	main.c: 148: delay(10000L); // Небольшая задержка для стабилизации шины
      00028D 4B 10            [ 1]  579 	push	#0x10
      00028F 4B 27            [ 1]  580 	push	#0x27
      000291 5F               [ 1]  581 	clrw	x
      000292 89               [ 2]  582 	pushw	x
      000293 CDr00r00         [ 4]  583 	call	_delay
                                    584 ;	main.c: 134: for (uint8_t addr = 1; addr < 127; addr++) {
      000296 0C 05            [ 1]  585 	inc	(0x05, sp)
      000298 20 C2            [ 2]  586 	jra	00105$
      00029A                        587 00103$:
                                    588 ;	main.c: 150: uart_write("Devs Not Found");
      00029A AEr00r76         [ 2]  589 	ldw	x, #(___str_12+0)
      00029D CDr00r2E         [ 4]  590 	call	_uart_write
                                    591 ;	main.c: 151: }
      0002A0 5B 05            [ 2]  592 	addw	sp, #5
      0002A2 81               [ 4]  593 	ret
                                    594 ;	main.c: 157: int main(void)
                                    595 ;	-----------------------------------------
                                    596 ;	 function main
                                    597 ;	-----------------------------------------
      0002A3                        598 _main:
                                    599 ;	main.c: 159: uart_init();
      0002A3 CDr01rE6         [ 4]  600 	call	_uart_init
                                    601 ;	main.c: 160: uart_write("Start Scanning\n");
      0002A6 AEr00r85         [ 2]  602 	ldw	x, #(___str_13+0)
      0002A9 CDr00r2E         [ 4]  603 	call	_uart_write
                                    604 ;	main.c: 161: i2c_init();
      0002AC CDr01rFF         [ 4]  605 	call	_i2c_init
                                    606 ;	main.c: 162: status_check();
      0002AF CDr01r1B         [ 4]  607 	call	_status_check
                                    608 ;	main.c: 165: i2c_scan(); 
      0002B2 CDr02r56         [ 4]  609 	call	_i2c_scan
                                    610 ;	main.c: 167: return 0;
      0002B5 5F               [ 1]  611 	clrw	x
                                    612 ;	main.c: 168: }
      0002B6 81               [ 4]  613 	ret
                                    614 	.area CODE
                                    615 	.area CONST
                                    616 	.area CONST
      000000                        617 ___str_0:
      000000 0A                     618 	.db 0x0a
      000001 53 52 31 20 2D 3E 20   619 	.ascii "SR1 -> "
      000008 00                     620 	.db 0x00
                                    621 	.area CODE
                                    622 	.area CONST
      000009                        623 ___str_1:
      000009 20 3C 2D               624 	.ascii " <-"
      00000C 0A                     625 	.db 0x0a
      00000D 00                     626 	.db 0x00
                                    627 	.area CODE
                                    628 	.area CONST
      00000E                        629 ___str_2:
      00000E 53 52 32 20 2D 3E 20   630 	.ascii "SR2 -> "
      000015 00                     631 	.db 0x00
                                    632 	.area CODE
                                    633 	.area CONST
      000016                        634 ___str_3:
      000016 53 52 33 20 2D 3E 20   635 	.ascii "SR3 -> "
      00001D 00                     636 	.db 0x00
                                    637 	.area CODE
                                    638 	.area CONST
      00001E                        639 ___str_4:
      00001E 43 52 31 20 2D 3E 20   640 	.ascii "CR1 -> "
      000025 00                     641 	.db 0x00
                                    642 	.area CODE
                                    643 	.area CONST
      000026                        644 ___str_5:
      000026 43 52 32 20 2D 3E 20   645 	.ascii "CR2 -> "
      00002D 00                     646 	.db 0x00
                                    647 	.area CODE
                                    648 	.area CONST
      00002E                        649 ___str_6:
      00002E 44 52 20 2D 3E 20      650 	.ascii "DR -> "
      000034 00                     651 	.db 0x00
                                    652 	.area CODE
                                    653 	.area CONST
      000035                        654 ___str_7:
      000035 53 74 61 72 74 20 67   655 	.ascii "Start generated"
             65 6E 65 72 61 74 65
             64
      000044 0A                     656 	.db 0x0a
      000045 00                     657 	.db 0x00
                                    658 	.area CODE
                                    659 	.area CONST
      000046                        660 ___str_8:
      000046 41 64 64 72 20 73 65   661 	.ascii "Addr send"
             6E 64
      00004F 0A                     662 	.db 0x0a
      000050 00                     663 	.db 0x00
                                    664 	.area CODE
                                    665 	.area CONST
      000051                        666 ___str_9:
      000051 53 74 6F 70 20 67 65   667 	.ascii "Stop generated"
             6E 65 72 61 74 65 64
      00005F 0A                     668 	.db 0x0a
      000060 00                     669 	.db 0x00
                                    670 	.area CODE
                                    671 	.area CONST
      000061                        672 ___str_10:
      000061 44 65 76 69 63 65 20   673 	.ascii "Device found at: "
             66 6F 75 6E 64 20 61
             74 3A 20
      000072 00                     674 	.db 0x00
                                    675 	.area CODE
                                    676 	.area CONST
      000073                        677 ___str_11:
      000073 0D                     678 	.db 0x0d
      000074 0A                     679 	.db 0x0a
      000075 00                     680 	.db 0x00
                                    681 	.area CODE
                                    682 	.area CONST
      000076                        683 ___str_12:
      000076 44 65 76 73 20 4E 6F   684 	.ascii "Devs Not Found"
             74 20 46 6F 75 6E 64
      000084 00                     685 	.db 0x00
                                    686 	.area CODE
                                    687 	.area CONST
      000085                        688 ___str_13:
      000085 53 74 61 72 74 20 53   689 	.ascii "Start Scanning"
             63 61 6E 6E 69 6E 67
      000093 0A                     690 	.db 0x0a
      000094 00                     691 	.db 0x00
                                    692 	.area CODE
                                    693 	.area INITIALIZER
                                    694 	.area CABS (ABS)
