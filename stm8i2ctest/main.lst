                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.3.0 #14184 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _status_check
                                     13 	.globl _uart_write_line
                                     14 	.globl _convert_int_to_binary
                                     15 	.globl _convert_int_to_chars
                                     16 	.globl _delay
                                     17 	.globl _strlen
                                     18 ;--------------------------------------------------------
                                     19 ; ram data
                                     20 ;--------------------------------------------------------
                                     21 	.area DATA
                                     22 ;--------------------------------------------------------
                                     23 ; ram data
                                     24 ;--------------------------------------------------------
                                     25 	.area INITIALIZED
                                     26 ;--------------------------------------------------------
                                     27 ; Stack segment in internal ram
                                     28 ;--------------------------------------------------------
                                     29 	.area SSEG
      000000                         30 __start__stack:
      000000                         31 	.ds	1
                                     32 
                                     33 ;--------------------------------------------------------
                                     34 ; absolute external ram data
                                     35 ;--------------------------------------------------------
                                     36 	.area DABS (ABS)
                                     37 
                                     38 ; default segment ordering for linker
                                     39 	.area HOME
                                     40 	.area GSINIT
                                     41 	.area GSFINAL
                                     42 	.area CONST
                                     43 	.area INITIALIZER
                                     44 	.area CODE
                                     45 
                                     46 ;--------------------------------------------------------
                                     47 ; interrupt vector
                                     48 ;--------------------------------------------------------
                                     49 	.area HOME
      000000                         50 __interrupt_vect:
      000000 82v00u00u00             51 	int s_GSINIT ; reset
                                     52 ;--------------------------------------------------------
                                     53 ; global & static initialisations
                                     54 ;--------------------------------------------------------
                                     55 	.area HOME
                                     56 	.area GSINIT
                                     57 	.area GSFINAL
                                     58 	.area GSINIT
      000000 CDr00r00         [ 4]   59 	call	___sdcc_external_startup
      000003 4D               [ 1]   60 	tnz	a
      000004 27 03            [ 1]   61 	jreq	__sdcc_init_data
      000006 CCr00r04         [ 2]   62 	jp	__sdcc_program_startup
      000009                         63 __sdcc_init_data:
                                     64 ; stm8_genXINIT() start
      000009 AEr00r00         [ 2]   65 	ldw x, #l_DATA
      00000C 27 07            [ 1]   66 	jreq	00002$
      00000E                         67 00001$:
      00000E 72 4FuFFuFF      [ 1]   68 	clr (s_DATA - 1, x)
      000012 5A               [ 2]   69 	decw x
      000013 26 F9            [ 1]   70 	jrne	00001$
      000015                         71 00002$:
      000015 AEr00r00         [ 2]   72 	ldw	x, #l_INITIALIZER
      000018 27 09            [ 1]   73 	jreq	00004$
      00001A                         74 00003$:
      00001A D6uFFuFF         [ 1]   75 	ld	a, (s_INITIALIZER - 1, x)
      00001D D7uFFuFF         [ 1]   76 	ld	(s_INITIALIZED - 1, x), a
      000020 5A               [ 2]   77 	decw	x
      000021 26 F7            [ 1]   78 	jrne	00003$
      000023                         79 00004$:
                                     80 ; stm8_genXINIT() end
                                     81 	.area GSFINAL
      000000 CCr00r04         [ 2]   82 	jp	__sdcc_program_startup
                                     83 ;--------------------------------------------------------
                                     84 ; Home
                                     85 ;--------------------------------------------------------
                                     86 	.area HOME
                                     87 	.area HOME
      000004                         88 __sdcc_program_startup:
      000004 CCr01r8C         [ 2]   89 	jp	_main
                                     90 ;	return from main will return to caller
                                     91 ;--------------------------------------------------------
                                     92 ; code
                                     93 ;--------------------------------------------------------
                                     94 	.area CODE
                                     95 ;	main.c: 7: void delay(unsigned long count) {
                                     96 ;	-----------------------------------------
                                     97 ;	 function delay
                                     98 ;	-----------------------------------------
      000000                         99 _delay:
      000000 52 08            [ 2]  100 	sub	sp, #8
                                    101 ;	main.c: 8: while (count--)
      000002 16 0D            [ 2]  102 	ldw	y, (0x0d, sp)
      000004 17 07            [ 2]  103 	ldw	(0x07, sp), y
      000006 1E 0B            [ 2]  104 	ldw	x, (0x0b, sp)
      000008                        105 00101$:
      000008 1F 01            [ 2]  106 	ldw	(0x01, sp), x
      00000A 7B 07            [ 1]  107 	ld	a, (0x07, sp)
      00000C 6B 03            [ 1]  108 	ld	(0x03, sp), a
      00000E 7B 08            [ 1]  109 	ld	a, (0x08, sp)
      000010 16 07            [ 2]  110 	ldw	y, (0x07, sp)
      000012 72 A2 00 01      [ 2]  111 	subw	y, #0x0001
      000016 17 07            [ 2]  112 	ldw	(0x07, sp), y
      000018 24 01            [ 1]  113 	jrnc	00117$
      00001A 5A               [ 2]  114 	decw	x
      00001B                        115 00117$:
      00001B 4D               [ 1]  116 	tnz	a
      00001C 26 08            [ 1]  117 	jrne	00118$
      00001E 16 02            [ 2]  118 	ldw	y, (0x02, sp)
      000020 26 04            [ 1]  119 	jrne	00118$
      000022 0D 01            [ 1]  120 	tnz	(0x01, sp)
      000024 27 03            [ 1]  121 	jreq	00104$
      000026                        122 00118$:
                                    123 ;	main.c: 9: nop();
      000026 9D               [ 1]  124 	nop
      000027 20 DF            [ 2]  125 	jra	00101$
      000029                        126 00104$:
                                    127 ;	main.c: 10: }
      000029 1E 09            [ 2]  128 	ldw	x, (9, sp)
      00002B 5B 0E            [ 2]  129 	addw	sp, #14
      00002D FC               [ 2]  130 	jp	(x)
                                    131 ;	main.c: 12: void convert_int_to_chars(int num, char* rx_int_chars) {
                                    132 ;	-----------------------------------------
                                    133 ;	 function convert_int_to_chars
                                    134 ;	-----------------------------------------
      00002E                        135 _convert_int_to_chars:
      00002E 52 0B            [ 2]  136 	sub	sp, #11
      000030 1F 0A            [ 2]  137 	ldw	(0x0a, sp), x
                                    138 ;	main.c: 15: rx_int_chars[0] = num / 100 + '0';
      000032 16 0E            [ 2]  139 	ldw	y, (0x0e, sp)
      000034 17 01            [ 2]  140 	ldw	(0x01, sp), y
                                    141 ;	main.c: 16: rx_int_chars[1] = num / 10 % 10 + '0';
      000036 4B 0A            [ 1]  142 	push	#0x0a
      000038 4B 00            [ 1]  143 	push	#0x00
      00003A 1E 0C            [ 2]  144 	ldw	x, (0x0c, sp)
                                    145 ;	main.c: 17: rx_int_chars[2] = num % 10 + '0';
      00003C CDr00r00         [ 4]  146 	call	__divsint
      00003F 1F 03            [ 2]  147 	ldw	(0x03, sp), x
      000041 4B 0A            [ 1]  148 	push	#0x0a
      000043 4B 00            [ 1]  149 	push	#0x00
      000045 1E 0C            [ 2]  150 	ldw	x, (0x0c, sp)
                                    151 ;	main.c: 16: rx_int_chars[1] = num / 10 % 10 + '0';
      000047 CDr00r00         [ 4]  152 	call	__modsint
      00004A 90 93            [ 1]  153 	ldw	y, x
      00004C 9F               [ 1]  154 	ld	a, xl
      00004D 1E 01            [ 2]  155 	ldw	x, (0x01, sp)
      00004F 5C               [ 1]  156 	incw	x
      000050 1F 05            [ 2]  157 	ldw	(0x05, sp), x
                                    158 ;	main.c: 17: rx_int_chars[2] = num % 10 + '0';
      000052 1E 01            [ 2]  159 	ldw	x, (0x01, sp)
      000054 5C               [ 1]  160 	incw	x
      000055 5C               [ 1]  161 	incw	x
      000056 1F 07            [ 2]  162 	ldw	(0x07, sp), x
      000058 AB 30            [ 1]  163 	add	a, #0x30
      00005A 6B 09            [ 1]  164 	ld	(0x09, sp), a
                                    165 ;	main.c: 13: if (num > 99) {
      00005C 1E 0A            [ 2]  166 	ldw	x, (0x0a, sp)
      00005E A3 00 63         [ 2]  167 	cpw	x, #0x0063
      000061 2D 29            [ 1]  168 	jrsle	00105$
                                    169 ;	main.c: 15: rx_int_chars[0] = num / 100 + '0';
      000063 4B 64            [ 1]  170 	push	#0x64
      000065 4B 00            [ 1]  171 	push	#0x00
      000067 1E 0C            [ 2]  172 	ldw	x, (0x0c, sp)
      000069 CDr00r00         [ 4]  173 	call	__divsint
      00006C 9F               [ 1]  174 	ld	a, xl
      00006D AB 30            [ 1]  175 	add	a, #0x30
      00006F 1E 01            [ 2]  176 	ldw	x, (0x01, sp)
      000071 F7               [ 1]  177 	ld	(x), a
                                    178 ;	main.c: 16: rx_int_chars[1] = num / 10 % 10 + '0';
      000072 4B 0A            [ 1]  179 	push	#0x0a
      000074 4B 00            [ 1]  180 	push	#0x00
      000076 1E 05            [ 2]  181 	ldw	x, (0x05, sp)
      000078 CDr00r00         [ 4]  182 	call	__modsint
      00007B 9F               [ 1]  183 	ld	a, xl
      00007C AB 30            [ 1]  184 	add	a, #0x30
      00007E 1E 05            [ 2]  185 	ldw	x, (0x05, sp)
      000080 F7               [ 1]  186 	ld	(x), a
                                    187 ;	main.c: 17: rx_int_chars[2] = num % 10 + '0';
      000081 1E 07            [ 2]  188 	ldw	x, (0x07, sp)
      000083 7B 09            [ 1]  189 	ld	a, (0x09, sp)
      000085 F7               [ 1]  190 	ld	(x), a
                                    191 ;	main.c: 18: rx_int_chars[3] ='\0';
      000086 1E 01            [ 2]  192 	ldw	x, (0x01, sp)
      000088 6F 03            [ 1]  193 	clr	(0x0003, x)
      00008A 20 22            [ 2]  194 	jra	00107$
      00008C                        195 00105$:
                                    196 ;	main.c: 20: } else if (num > 9) {
      00008C 1E 0A            [ 2]  197 	ldw	x, (0x0a, sp)
      00008E A3 00 09         [ 2]  198 	cpw	x, #0x0009
      000091 2D 11            [ 1]  199 	jrsle	00102$
                                    200 ;	main.c: 22: rx_int_chars[0] = num / 10 + '0';
      000093 7B 04            [ 1]  201 	ld	a, (0x04, sp)
      000095 AB 30            [ 1]  202 	add	a, #0x30
      000097 1E 01            [ 2]  203 	ldw	x, (0x01, sp)
      000099 F7               [ 1]  204 	ld	(x), a
                                    205 ;	main.c: 23: rx_int_chars[1] = num % 10 + '0';
      00009A 1E 05            [ 2]  206 	ldw	x, (0x05, sp)
      00009C 7B 09            [ 1]  207 	ld	a, (0x09, sp)
      00009E F7               [ 1]  208 	ld	(x), a
                                    209 ;	main.c: 24: rx_int_chars[2] ='\0';
      00009F 1E 07            [ 2]  210 	ldw	x, (0x07, sp)
      0000A1 7F               [ 1]  211 	clr	(x)
      0000A2 20 0A            [ 2]  212 	jra	00107$
      0000A4                        213 00102$:
                                    214 ;	main.c: 29: rx_int_chars[0] = num + '0';
      0000A4 7B 0B            [ 1]  215 	ld	a, (0x0b, sp)
      0000A6 AB 30            [ 1]  216 	add	a, #0x30
      0000A8 1E 01            [ 2]  217 	ldw	x, (0x01, sp)
      0000AA F7               [ 1]  218 	ld	(x), a
                                    219 ;	main.c: 30: rx_int_chars[1] ='\0';
      0000AB 1E 05            [ 2]  220 	ldw	x, (0x05, sp)
      0000AD 7F               [ 1]  221 	clr	(x)
      0000AE                        222 00107$:
                                    223 ;	main.c: 32: }
      0000AE 1E 0C            [ 2]  224 	ldw	x, (12, sp)
      0000B0 5B 0F            [ 2]  225 	addw	sp, #15
      0000B2 FC               [ 2]  226 	jp	(x)
                                    227 ;	main.c: 34: void convert_int_to_binary(int num, char* rx_binary_chars) {
                                    228 ;	-----------------------------------------
                                    229 ;	 function convert_int_to_binary
                                    230 ;	-----------------------------------------
      0000B3                        231 _convert_int_to_binary:
      0000B3 52 04            [ 2]  232 	sub	sp, #4
      0000B5 1F 01            [ 2]  233 	ldw	(0x01, sp), x
                                    234 ;	main.c: 36: for(int i = 7; i >= 0; i--) {
      0000B7 AE 00 07         [ 2]  235 	ldw	x, #0x0007
      0000BA 1F 03            [ 2]  236 	ldw	(0x03, sp), x
      0000BC                        237 00103$:
      0000BC 0D 03            [ 1]  238 	tnz	(0x03, sp)
      0000BE 2B 22            [ 1]  239 	jrmi	00101$
                                    240 ;	main.c: 38: rx_binary_chars[7 - i] = ((num >> i) & 1) + '0';
      0000C0 AE 00 07         [ 2]  241 	ldw	x, #0x0007
      0000C3 72 F0 03         [ 2]  242 	subw	x, (0x03, sp)
      0000C6 72 FB 07         [ 2]  243 	addw	x, (0x07, sp)
      0000C9 16 01            [ 2]  244 	ldw	y, (0x01, sp)
      0000CB 7B 04            [ 1]  245 	ld	a, (0x04, sp)
      0000CD 27 05            [ 1]  246 	jreq	00120$
      0000CF                        247 00119$:
      0000CF 90 57            [ 2]  248 	sraw	y
      0000D1 4A               [ 1]  249 	dec	a
      0000D2 26 FB            [ 1]  250 	jrne	00119$
      0000D4                        251 00120$:
      0000D4 90 9F            [ 1]  252 	ld	a, yl
      0000D6 A4 01            [ 1]  253 	and	a, #0x01
      0000D8 AB 30            [ 1]  254 	add	a, #0x30
      0000DA F7               [ 1]  255 	ld	(x), a
                                    256 ;	main.c: 36: for(int i = 7; i >= 0; i--) {
      0000DB 1E 03            [ 2]  257 	ldw	x, (0x03, sp)
      0000DD 5A               [ 2]  258 	decw	x
      0000DE 1F 03            [ 2]  259 	ldw	(0x03, sp), x
      0000E0 20 DA            [ 2]  260 	jra	00103$
      0000E2                        261 00101$:
                                    262 ;	main.c: 40: rx_binary_chars[8] = '\0'; // Добавляем символ конца строки
      0000E2 1E 07            [ 2]  263 	ldw	x, (0x07, sp)
      0000E4 6F 08            [ 1]  264 	clr	(0x0008, x)
                                    265 ;	main.c: 41: }
      0000E6 1E 05            [ 2]  266 	ldw	x, (5, sp)
      0000E8 5B 08            [ 2]  267 	addw	sp, #8
      0000EA FC               [ 2]  268 	jp	(x)
                                    269 ;	main.c: 46: int uart_write_line(const char *str) {
                                    270 ;	-----------------------------------------
                                    271 ;	 function uart_write_line
                                    272 ;	-----------------------------------------
      0000EB                        273 _uart_write_line:
      0000EB 52 05            [ 2]  274 	sub	sp, #5
      0000ED 1F 03            [ 2]  275 	ldw	(0x03, sp), x
                                    276 ;	main.c: 48: for(i = 0; i < strlen(str); i++) {
      0000EF 0F 05            [ 1]  277 	clr	(0x05, sp)
      0000F1                        278 00106$:
      0000F1 1E 03            [ 2]  279 	ldw	x, (0x03, sp)
      0000F3 CDr00r00         [ 4]  280 	call	_strlen
      0000F6 1F 01            [ 2]  281 	ldw	(0x01, sp), x
      0000F8 5F               [ 1]  282 	clrw	x
      0000F9 7B 05            [ 1]  283 	ld	a, (0x05, sp)
      0000FB 97               [ 1]  284 	ld	xl, a
      0000FC 13 01            [ 2]  285 	cpw	x, (0x01, sp)
      0000FE 24 14            [ 1]  286 	jrnc	00104$
                                    287 ;	main.c: 49: while(!(UART1_SR & UART_SR_TXE)); // !Transmit data register empty
      000100                        288 00101$:
      000100 C6 52 30         [ 1]  289 	ld	a, 0x5230
      000103 2A FB            [ 1]  290 	jrpl	00101$
                                    291 ;	main.c: 50: UART1_DR = str[i];
      000105 5F               [ 1]  292 	clrw	x
      000106 7B 05            [ 1]  293 	ld	a, (0x05, sp)
      000108 97               [ 1]  294 	ld	xl, a
      000109 72 FB 03         [ 2]  295 	addw	x, (0x03, sp)
      00010C F6               [ 1]  296 	ld	a, (x)
      00010D C7 52 31         [ 1]  297 	ld	0x5231, a
                                    298 ;	main.c: 48: for(i = 0; i < strlen(str); i++) {
      000110 0C 05            [ 1]  299 	inc	(0x05, sp)
      000112 20 DD            [ 2]  300 	jra	00106$
      000114                        301 00104$:
                                    302 ;	main.c: 52: return(i); // Bytes sent
      000114 7B 05            [ 1]  303 	ld	a, (0x05, sp)
      000116 5F               [ 1]  304 	clrw	x
      000117 97               [ 1]  305 	ld	xl, a
                                    306 ;	main.c: 53: }
      000118 5B 05            [ 2]  307 	addw	sp, #5
      00011A 81               [ 4]  308 	ret
                                    309 ;	main.c: 55: void status_check(void){
                                    310 ;	-----------------------------------------
                                    311 ;	 function status_check
                                    312 ;	-----------------------------------------
      00011B                        313 _status_check:
      00011B 52 09            [ 2]  314 	sub	sp, #9
                                    315 ;	main.c: 56: char rx_binary_chars[9]={0};
      00011D 0F 01            [ 1]  316 	clr	(0x01, sp)
      00011F 0F 02            [ 1]  317 	clr	(0x02, sp)
      000121 0F 03            [ 1]  318 	clr	(0x03, sp)
      000123 0F 04            [ 1]  319 	clr	(0x04, sp)
      000125 0F 05            [ 1]  320 	clr	(0x05, sp)
      000127 0F 06            [ 1]  321 	clr	(0x06, sp)
      000129 0F 07            [ 1]  322 	clr	(0x07, sp)
      00012B 0F 08            [ 1]  323 	clr	(0x08, sp)
      00012D 0F 09            [ 1]  324 	clr	(0x09, sp)
                                    325 ;	main.c: 57: convert_int_to_binary(I2C_SR1, rx_binary_chars);
      00012F 96               [ 1]  326 	ldw	x, sp
      000130 5C               [ 1]  327 	incw	x
      000131 51               [ 1]  328 	exgw	x, y
      000132 C6 52 17         [ 1]  329 	ld	a, 0x5217
      000135 5F               [ 1]  330 	clrw	x
      000136 90 89            [ 2]  331 	pushw	y
      000138 97               [ 1]  332 	ld	xl, a
      000139 CDr00rB3         [ 4]  333 	call	_convert_int_to_binary
                                    334 ;	main.c: 58: uart_write_line("SR1 -> ");
      00013C AEr00r00         [ 2]  335 	ldw	x, #(___str_0+0)
      00013F CDr00rEB         [ 4]  336 	call	_uart_write_line
                                    337 ;	main.c: 59: uart_write_line(rx_binary_chars);
      000142 96               [ 1]  338 	ldw	x, sp
      000143 5C               [ 1]  339 	incw	x
      000144 CDr00rEB         [ 4]  340 	call	_uart_write_line
                                    341 ;	main.c: 60: uart_write_line(" <-\n");
      000147 AEr00r08         [ 2]  342 	ldw	x, #(___str_1+0)
      00014A CDr00rEB         [ 4]  343 	call	_uart_write_line
                                    344 ;	main.c: 61: convert_int_to_binary(I2C_SR2, rx_binary_chars);
      00014D 96               [ 1]  345 	ldw	x, sp
      00014E 5C               [ 1]  346 	incw	x
      00014F 51               [ 1]  347 	exgw	x, y
      000150 C6 52 18         [ 1]  348 	ld	a, 0x5218
      000153 5F               [ 1]  349 	clrw	x
      000154 90 89            [ 2]  350 	pushw	y
      000156 97               [ 1]  351 	ld	xl, a
      000157 CDr00rB3         [ 4]  352 	call	_convert_int_to_binary
                                    353 ;	main.c: 62: uart_write_line("SR2 -> ");
      00015A AEr00r0D         [ 2]  354 	ldw	x, #(___str_2+0)
      00015D CDr00rEB         [ 4]  355 	call	_uart_write_line
                                    356 ;	main.c: 63: uart_write_line(rx_binary_chars);
      000160 96               [ 1]  357 	ldw	x, sp
      000161 5C               [ 1]  358 	incw	x
      000162 CDr00rEB         [ 4]  359 	call	_uart_write_line
                                    360 ;	main.c: 64: uart_write_line(" <-\n");
      000165 AEr00r08         [ 2]  361 	ldw	x, #(___str_1+0)
      000168 CDr00rEB         [ 4]  362 	call	_uart_write_line
                                    363 ;	main.c: 65: convert_int_to_binary(I2C_SR3, rx_binary_chars);
      00016B 96               [ 1]  364 	ldw	x, sp
      00016C 5C               [ 1]  365 	incw	x
      00016D 51               [ 1]  366 	exgw	x, y
      00016E C6 52 19         [ 1]  367 	ld	a, 0x5219
      000171 5F               [ 1]  368 	clrw	x
      000172 90 89            [ 2]  369 	pushw	y
      000174 97               [ 1]  370 	ld	xl, a
      000175 CDr00rB3         [ 4]  371 	call	_convert_int_to_binary
                                    372 ;	main.c: 66: uart_write_line("SR3 -> ");
      000178 AEr00r15         [ 2]  373 	ldw	x, #(___str_3+0)
      00017B CDr00rEB         [ 4]  374 	call	_uart_write_line
                                    375 ;	main.c: 67: uart_write_line(rx_binary_chars);
      00017E 96               [ 1]  376 	ldw	x, sp
      00017F 5C               [ 1]  377 	incw	x
      000180 CDr00rEB         [ 4]  378 	call	_uart_write_line
                                    379 ;	main.c: 68: uart_write_line(" <-\n");
      000183 AEr00r08         [ 2]  380 	ldw	x, #(___str_1+0)
      000186 CDr00rEB         [ 4]  381 	call	_uart_write_line
                                    382 ;	main.c: 69: }
      000189 5B 09            [ 2]  383 	addw	sp, #9
      00018B 81               [ 4]  384 	ret
                                    385 ;	main.c: 71: int main(void)
                                    386 ;	-----------------------------------------
                                    387 ;	 function main
                                    388 ;	-----------------------------------------
      00018C                        389 _main:
      00018C 52 05            [ 2]  390 	sub	sp, #5
                                    391 ;	main.c: 74: CLK_CKDIVR = 0;
      00018E 35 00 50 C6      [ 1]  392 	mov	0x50c6+0, #0x00
                                    393 ;	main.c: 77: UART1_CR2 |= UART_CR2_TEN; // Transmitter enable
      000192 72 16 52 35      [ 1]  394 	bset	0x5235, #3
                                    395 ;	main.c: 79: UART1_CR3 &= ~(UART_CR3_STOP1 | UART_CR3_STOP2); // 1 stop bit
      000196 C6 52 36         [ 1]  396 	ld	a, 0x5236
      000199 A4 CF            [ 1]  397 	and	a, #0xcf
      00019B C7 52 36         [ 1]  398 	ld	0x5236, a
                                    399 ;	main.c: 81: UART1_BRR2 = 0x03; UART1_BRR1 = 0x68; // 0x0683 coded funky way (see ref manual)
      00019E 35 03 52 33      [ 1]  400 	mov	0x5233+0, #0x03
      0001A2 35 68 52 32      [ 1]  401 	mov	0x5232+0, #0x68
                                    402 ;	main.c: 85: I2C_CR1 = I2C_CR1 & ~0x01;      // PE=0, disable I2C before setup
      0001A6 72 11 52 10      [ 1]  403 	bres	0x5210, #0
                                    404 ;	main.c: 86: I2C_FREQR= 16;                  // peripheral frequence =16MHz
      0001AA 35 10 52 12      [ 1]  405 	mov	0x5212+0, #0x10
                                    406 ;	main.c: 87: I2C_CCRH = 0;                   // =0
      0001AE 35 00 52 1C      [ 1]  407 	mov	0x521c+0, #0x00
                                    408 ;	main.c: 88: I2C_CCRL = 80;                  // 100kHz for I2C
      0001B2 35 50 52 1B      [ 1]  409 	mov	0x521b+0, #0x50
                                    410 ;	main.c: 89: I2C_CCRH = I2C_CCRH & ~0x80;    // set standart mode(100кHz)
      0001B6 72 1F 52 1C      [ 1]  411 	bres	0x521c, #7
                                    412 ;	main.c: 90: I2C_OARH = I2C_OARH & ~0x80;    // 7-bit address mode
      0001BA 72 1F 52 14      [ 1]  413 	bres	0x5214, #7
                                    414 ;	main.c: 91: I2C_OARH = I2C_OARH | 0x40;     // see reference manual
      0001BE 72 1C 52 14      [ 1]  415 	bset	0x5214, #6
                                    416 ;	main.c: 92: I2C_CR1 = I2C_CR1 | 0x01;       // PE=1, enable I2C
      0001C2 72 10 52 10      [ 1]  417 	bset	0x5210, #0
                                    418 ;	main.c: 98: uart_write_line("Start Scanning\n");
      0001C6 AEr00r1D         [ 2]  419 	ldw	x, #(___str_4+0)
      0001C9 CDr00rEB         [ 4]  420 	call	_uart_write_line
                                    421 ;	main.c: 100: for(uint8_t addr = 0x00; addr < 0xFF;addr++)
      0001CC 0F 05            [ 1]  422 	clr	(0x05, sp)
      0001CE                        423 00106$:
      0001CE 7B 05            [ 1]  424 	ld	a, (0x05, sp)
      0001D0 A1 FF            [ 1]  425 	cp	a, #0xff
      0001D2 24 6C            [ 1]  426 	jrnc	00104$
                                    427 ;	main.c: 103: uart_write_line("_______Start______\n");
      0001D4 AEr00r2D         [ 2]  428 	ldw	x, #(___str_5+0)
      0001D7 CDr00rEB         [ 4]  429 	call	_uart_write_line
                                    430 ;	main.c: 104: uart_write_line("Dev ->  ");
      0001DA AEr00r41         [ 2]  431 	ldw	x, #(___str_6+0)
      0001DD CDr00rEB         [ 4]  432 	call	_uart_write_line
                                    433 ;	main.c: 105: char rx_int_chars[4]={0};
      0001E0 0F 01            [ 1]  434 	clr	(0x01, sp)
      0001E2 0F 02            [ 1]  435 	clr	(0x02, sp)
      0001E4 0F 03            [ 1]  436 	clr	(0x03, sp)
      0001E6 0F 04            [ 1]  437 	clr	(0x04, sp)
                                    438 ;	main.c: 107: convert_int_to_chars(addr, rx_int_chars);
      0001E8 96               [ 1]  439 	ldw	x, sp
      0001E9 5C               [ 1]  440 	incw	x
      0001EA 51               [ 1]  441 	exgw	x, y
      0001EB 7B 05            [ 1]  442 	ld	a, (0x05, sp)
      0001ED 5F               [ 1]  443 	clrw	x
      0001EE 90 89            [ 2]  444 	pushw	y
      0001F0 97               [ 1]  445 	ld	xl, a
      0001F1 CDr00r2E         [ 4]  446 	call	_convert_int_to_chars
                                    447 ;	main.c: 108: uart_write_line(rx_int_chars);
      0001F4 96               [ 1]  448 	ldw	x, sp
      0001F5 5C               [ 1]  449 	incw	x
      0001F6 CDr00rEB         [ 4]  450 	call	_uart_write_line
                                    451 ;	main.c: 109: uart_write_line("  <- Dev\n");
      0001F9 AEr00r4A         [ 2]  452 	ldw	x, #(___str_7+0)
      0001FC CDr00rEB         [ 4]  453 	call	_uart_write_line
                                    454 ;	main.c: 110: status_check();
      0001FF CDr01r1B         [ 4]  455 	call	_status_check
                                    456 ;	main.c: 113: I2C_CR2 = I2C_CR2 | (1 << 2); // Set ACK bit
      000202 72 14 52 11      [ 1]  457 	bset	0x5211, #2
                                    458 ;	main.c: 114: I2C_CR2 = I2C_CR2 | (1 << 0); // START
      000206 72 10 52 11      [ 1]  459 	bset	0x5211, #0
                                    460 ;	main.c: 115: uart_write_line("flag\n");
      00020A AEr00r54         [ 2]  461 	ldw	x, #(___str_8+0)
      00020D CDr00rEB         [ 4]  462 	call	_uart_write_line
                                    463 ;	main.c: 116: while (!(I2C_SR1 & (1 << 0)));
      000210                        464 00101$:
      000210 72 01 52 17 FB   [ 2]  465 	btjf	0x5217, #0, 00101$
                                    466 ;	main.c: 117: uart_write_line("flag1\n");
      000215 AEr00r5A         [ 2]  467 	ldw	x, #(___str_9+0)
      000218 CDr00rEB         [ 4]  468 	call	_uart_write_line
                                    469 ;	main.c: 118: I2C_SR1 = I2C_SR1 | 0x00;
      00021B 55 52 17 52 17   [ 1]  470 	mov	0x5217, 0x5217
                                    471 ;	main.c: 119: I2C_DR = I2C_DR | addr;
      000220 C6 52 16         [ 1]  472 	ld	a, 0x5216
      000223 1A 05            [ 1]  473 	or	a, (0x05, sp)
      000225 C7 52 16         [ 1]  474 	ld	0x5216, a
                                    475 ;	main.c: 120: status_check();
      000228 CDr01r1B         [ 4]  476 	call	_status_check
                                    477 ;	main.c: 126: I2C_SR1 = 0x00;
      00022B 35 00 52 17      [ 1]  478 	mov	0x5217+0, #0x00
                                    479 ;	main.c: 127: I2C_SR3 = 0x00;
      00022F 35 00 52 19      [ 1]  480 	mov	0x5219+0, #0x00
                                    481 ;	main.c: 128: status_check();
      000233 CDr01r1B         [ 4]  482 	call	_status_check
                                    483 ;	main.c: 131: uart_write_line("_______Stop_______\n");
      000236 AEr00r61         [ 2]  484 	ldw	x, #(___str_10+0)
      000239 CDr00rEB         [ 4]  485 	call	_uart_write_line
                                    486 ;	main.c: 100: for(uint8_t addr = 0x00; addr < 0xFF;addr++)
      00023C 0C 05            [ 1]  487 	inc	(0x05, sp)
      00023E 20 8E            [ 2]  488 	jra	00106$
      000240                        489 00104$:
                                    490 ;	main.c: 137: return 0;
      000240 5F               [ 1]  491 	clrw	x
                                    492 ;	main.c: 138: }
      000241 5B 05            [ 2]  493 	addw	sp, #5
      000243 81               [ 4]  494 	ret
                                    495 	.area CODE
                                    496 	.area CONST
                                    497 	.area CONST
      000000                        498 ___str_0:
      000000 53 52 31 20 2D 3E 20   499 	.ascii "SR1 -> "
      000007 00                     500 	.db 0x00
                                    501 	.area CODE
                                    502 	.area CONST
      000008                        503 ___str_1:
      000008 20 3C 2D               504 	.ascii " <-"
      00000B 0A                     505 	.db 0x0a
      00000C 00                     506 	.db 0x00
                                    507 	.area CODE
                                    508 	.area CONST
      00000D                        509 ___str_2:
      00000D 53 52 32 20 2D 3E 20   510 	.ascii "SR2 -> "
      000014 00                     511 	.db 0x00
                                    512 	.area CODE
                                    513 	.area CONST
      000015                        514 ___str_3:
      000015 53 52 33 20 2D 3E 20   515 	.ascii "SR3 -> "
      00001C 00                     516 	.db 0x00
                                    517 	.area CODE
                                    518 	.area CONST
      00001D                        519 ___str_4:
      00001D 53 74 61 72 74 20 53   520 	.ascii "Start Scanning"
             63 61 6E 6E 69 6E 67
      00002B 0A                     521 	.db 0x0a
      00002C 00                     522 	.db 0x00
                                    523 	.area CODE
                                    524 	.area CONST
      00002D                        525 ___str_5:
      00002D 5F 5F 5F 5F 5F 5F 5F   526 	.ascii "_______Start______"
             53 74 61 72 74 5F 5F
             5F 5F 5F 5F
      00003F 0A                     527 	.db 0x0a
      000040 00                     528 	.db 0x00
                                    529 	.area CODE
                                    530 	.area CONST
      000041                        531 ___str_6:
      000041 44 65 76 20 2D 3E 20   532 	.ascii "Dev ->  "
             20
      000049 00                     533 	.db 0x00
                                    534 	.area CODE
                                    535 	.area CONST
      00004A                        536 ___str_7:
      00004A 20 20 3C 2D 20 44 65   537 	.ascii "  <- Dev"
             76
      000052 0A                     538 	.db 0x0a
      000053 00                     539 	.db 0x00
                                    540 	.area CODE
                                    541 	.area CONST
      000054                        542 ___str_8:
      000054 66 6C 61 67            543 	.ascii "flag"
      000058 0A                     544 	.db 0x0a
      000059 00                     545 	.db 0x00
                                    546 	.area CODE
                                    547 	.area CONST
      00005A                        548 ___str_9:
      00005A 66 6C 61 67 31         549 	.ascii "flag1"
      00005F 0A                     550 	.db 0x0a
      000060 00                     551 	.db 0x00
                                    552 	.area CODE
                                    553 	.area CONST
      000061                        554 ___str_10:
      000061 5F 5F 5F 5F 5F 5F 5F   555 	.ascii "_______Stop_______"
             53 74 6F 70 5F 5F 5F
             5F 5F 5F 5F
      000073 0A                     556 	.db 0x0a
      000074 00                     557 	.db 0x00
                                    558 	.area CODE
                                    559 	.area INITIALIZER
                                    560 	.area CABS (ABS)
