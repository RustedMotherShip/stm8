                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.3.0 #14184 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _status_check
                                     13 	.globl _uart_write_line
                                     14 	.globl _convert_int_to_binary
                                     15 	.globl _convert_int_to_chars
                                     16 	.globl _delay
                                     17 	.globl _strlen
                                     18 ;--------------------------------------------------------
                                     19 ; ram data
                                     20 ;--------------------------------------------------------
                                     21 	.area DATA
                                     22 ;--------------------------------------------------------
                                     23 ; ram data
                                     24 ;--------------------------------------------------------
                                     25 	.area INITIALIZED
                                     26 ;--------------------------------------------------------
                                     27 ; Stack segment in internal ram
                                     28 ;--------------------------------------------------------
                                     29 	.area SSEG
      000000                         30 __start__stack:
      000000                         31 	.ds	1
                                     32 
                                     33 ;--------------------------------------------------------
                                     34 ; absolute external ram data
                                     35 ;--------------------------------------------------------
                                     36 	.area DABS (ABS)
                                     37 
                                     38 ; default segment ordering for linker
                                     39 	.area HOME
                                     40 	.area GSINIT
                                     41 	.area GSFINAL
                                     42 	.area CONST
                                     43 	.area INITIALIZER
                                     44 	.area CODE
                                     45 
                                     46 ;--------------------------------------------------------
                                     47 ; interrupt vector
                                     48 ;--------------------------------------------------------
                                     49 	.area HOME
      000000                         50 __interrupt_vect:
      000000 82v00u00u00             51 	int s_GSINIT ; reset
                                     52 ;--------------------------------------------------------
                                     53 ; global & static initialisations
                                     54 ;--------------------------------------------------------
                                     55 	.area HOME
                                     56 	.area GSINIT
                                     57 	.area GSFINAL
                                     58 	.area GSINIT
      000000 CDr00r00         [ 4]   59 	call	___sdcc_external_startup
      000003 4D               [ 1]   60 	tnz	a
      000004 27 03            [ 1]   61 	jreq	__sdcc_init_data
      000006 CCr00r04         [ 2]   62 	jp	__sdcc_program_startup
      000009                         63 __sdcc_init_data:
                                     64 ; stm8_genXINIT() start
      000009 AEr00r00         [ 2]   65 	ldw x, #l_DATA
      00000C 27 07            [ 1]   66 	jreq	00002$
      00000E                         67 00001$:
      00000E 72 4FuFFuFF      [ 1]   68 	clr (s_DATA - 1, x)
      000012 5A               [ 2]   69 	decw x
      000013 26 F9            [ 1]   70 	jrne	00001$
      000015                         71 00002$:
      000015 AEr00r00         [ 2]   72 	ldw	x, #l_INITIALIZER
      000018 27 09            [ 1]   73 	jreq	00004$
      00001A                         74 00003$:
      00001A D6uFFuFF         [ 1]   75 	ld	a, (s_INITIALIZER - 1, x)
      00001D D7uFFuFF         [ 1]   76 	ld	(s_INITIALIZED - 1, x), a
      000020 5A               [ 2]   77 	decw	x
      000021 26 F7            [ 1]   78 	jrne	00003$
      000023                         79 00004$:
                                     80 ; stm8_genXINIT() end
                                     81 	.area GSFINAL
      000000 CCr00r04         [ 2]   82 	jp	__sdcc_program_startup
                                     83 ;--------------------------------------------------------
                                     84 ; Home
                                     85 ;--------------------------------------------------------
                                     86 	.area HOME
                                     87 	.area HOME
      000004                         88 __sdcc_program_startup:
      000004 CCr01rC8         [ 2]   89 	jp	_main
                                     90 ;	return from main will return to caller
                                     91 ;--------------------------------------------------------
                                     92 ; code
                                     93 ;--------------------------------------------------------
                                     94 	.area CODE
                                     95 ;	main.c: 7: void delay(unsigned long count) {
                                     96 ;	-----------------------------------------
                                     97 ;	 function delay
                                     98 ;	-----------------------------------------
      000000                         99 _delay:
      000000 52 08            [ 2]  100 	sub	sp, #8
                                    101 ;	main.c: 8: while (count--)
      000002 16 0D            [ 2]  102 	ldw	y, (0x0d, sp)
      000004 17 07            [ 2]  103 	ldw	(0x07, sp), y
      000006 1E 0B            [ 2]  104 	ldw	x, (0x0b, sp)
      000008                        105 00101$:
      000008 1F 01            [ 2]  106 	ldw	(0x01, sp), x
      00000A 7B 07            [ 1]  107 	ld	a, (0x07, sp)
      00000C 6B 03            [ 1]  108 	ld	(0x03, sp), a
      00000E 7B 08            [ 1]  109 	ld	a, (0x08, sp)
      000010 16 07            [ 2]  110 	ldw	y, (0x07, sp)
      000012 72 A2 00 01      [ 2]  111 	subw	y, #0x0001
      000016 17 07            [ 2]  112 	ldw	(0x07, sp), y
      000018 24 01            [ 1]  113 	jrnc	00117$
      00001A 5A               [ 2]  114 	decw	x
      00001B                        115 00117$:
      00001B 4D               [ 1]  116 	tnz	a
      00001C 26 08            [ 1]  117 	jrne	00118$
      00001E 16 02            [ 2]  118 	ldw	y, (0x02, sp)
      000020 26 04            [ 1]  119 	jrne	00118$
      000022 0D 01            [ 1]  120 	tnz	(0x01, sp)
      000024 27 03            [ 1]  121 	jreq	00104$
      000026                        122 00118$:
                                    123 ;	main.c: 9: nop();
      000026 9D               [ 1]  124 	nop
      000027 20 DF            [ 2]  125 	jra	00101$
      000029                        126 00104$:
                                    127 ;	main.c: 10: }
      000029 1E 09            [ 2]  128 	ldw	x, (9, sp)
      00002B 5B 0E            [ 2]  129 	addw	sp, #14
      00002D FC               [ 2]  130 	jp	(x)
                                    131 ;	main.c: 12: void convert_int_to_chars(int num, char* rx_int_chars) {
                                    132 ;	-----------------------------------------
                                    133 ;	 function convert_int_to_chars
                                    134 ;	-----------------------------------------
      00002E                        135 _convert_int_to_chars:
      00002E 52 0B            [ 2]  136 	sub	sp, #11
      000030 1F 0A            [ 2]  137 	ldw	(0x0a, sp), x
                                    138 ;	main.c: 15: rx_int_chars[0] = num / 100 + '0';
      000032 16 0E            [ 2]  139 	ldw	y, (0x0e, sp)
      000034 17 01            [ 2]  140 	ldw	(0x01, sp), y
                                    141 ;	main.c: 16: rx_int_chars[1] = num / 10 % 10 + '0';
      000036 4B 0A            [ 1]  142 	push	#0x0a
      000038 4B 00            [ 1]  143 	push	#0x00
      00003A 1E 0C            [ 2]  144 	ldw	x, (0x0c, sp)
                                    145 ;	main.c: 17: rx_int_chars[2] = num % 10 + '0';
      00003C CDr00r00         [ 4]  146 	call	__divsint
      00003F 1F 03            [ 2]  147 	ldw	(0x03, sp), x
      000041 4B 0A            [ 1]  148 	push	#0x0a
      000043 4B 00            [ 1]  149 	push	#0x00
      000045 1E 0C            [ 2]  150 	ldw	x, (0x0c, sp)
                                    151 ;	main.c: 16: rx_int_chars[1] = num / 10 % 10 + '0';
      000047 CDr00r00         [ 4]  152 	call	__modsint
      00004A 90 93            [ 1]  153 	ldw	y, x
      00004C 9F               [ 1]  154 	ld	a, xl
      00004D 1E 01            [ 2]  155 	ldw	x, (0x01, sp)
      00004F 5C               [ 1]  156 	incw	x
      000050 1F 05            [ 2]  157 	ldw	(0x05, sp), x
                                    158 ;	main.c: 17: rx_int_chars[2] = num % 10 + '0';
      000052 1E 01            [ 2]  159 	ldw	x, (0x01, sp)
      000054 5C               [ 1]  160 	incw	x
      000055 5C               [ 1]  161 	incw	x
      000056 1F 07            [ 2]  162 	ldw	(0x07, sp), x
      000058 AB 30            [ 1]  163 	add	a, #0x30
      00005A 6B 09            [ 1]  164 	ld	(0x09, sp), a
                                    165 ;	main.c: 13: if (num > 99) {
      00005C 1E 0A            [ 2]  166 	ldw	x, (0x0a, sp)
      00005E A3 00 63         [ 2]  167 	cpw	x, #0x0063
      000061 2D 29            [ 1]  168 	jrsle	00105$
                                    169 ;	main.c: 15: rx_int_chars[0] = num / 100 + '0';
      000063 4B 64            [ 1]  170 	push	#0x64
      000065 4B 00            [ 1]  171 	push	#0x00
      000067 1E 0C            [ 2]  172 	ldw	x, (0x0c, sp)
      000069 CDr00r00         [ 4]  173 	call	__divsint
      00006C 9F               [ 1]  174 	ld	a, xl
      00006D AB 30            [ 1]  175 	add	a, #0x30
      00006F 1E 01            [ 2]  176 	ldw	x, (0x01, sp)
      000071 F7               [ 1]  177 	ld	(x), a
                                    178 ;	main.c: 16: rx_int_chars[1] = num / 10 % 10 + '0';
      000072 4B 0A            [ 1]  179 	push	#0x0a
      000074 4B 00            [ 1]  180 	push	#0x00
      000076 1E 05            [ 2]  181 	ldw	x, (0x05, sp)
      000078 CDr00r00         [ 4]  182 	call	__modsint
      00007B 9F               [ 1]  183 	ld	a, xl
      00007C AB 30            [ 1]  184 	add	a, #0x30
      00007E 1E 05            [ 2]  185 	ldw	x, (0x05, sp)
      000080 F7               [ 1]  186 	ld	(x), a
                                    187 ;	main.c: 17: rx_int_chars[2] = num % 10 + '0';
      000081 1E 07            [ 2]  188 	ldw	x, (0x07, sp)
      000083 7B 09            [ 1]  189 	ld	a, (0x09, sp)
      000085 F7               [ 1]  190 	ld	(x), a
                                    191 ;	main.c: 18: rx_int_chars[3] ='\0';
      000086 1E 01            [ 2]  192 	ldw	x, (0x01, sp)
      000088 6F 03            [ 1]  193 	clr	(0x0003, x)
      00008A 20 22            [ 2]  194 	jra	00107$
      00008C                        195 00105$:
                                    196 ;	main.c: 20: } else if (num > 9) {
      00008C 1E 0A            [ 2]  197 	ldw	x, (0x0a, sp)
      00008E A3 00 09         [ 2]  198 	cpw	x, #0x0009
      000091 2D 11            [ 1]  199 	jrsle	00102$
                                    200 ;	main.c: 22: rx_int_chars[0] = num / 10 + '0';
      000093 7B 04            [ 1]  201 	ld	a, (0x04, sp)
      000095 AB 30            [ 1]  202 	add	a, #0x30
      000097 1E 01            [ 2]  203 	ldw	x, (0x01, sp)
      000099 F7               [ 1]  204 	ld	(x), a
                                    205 ;	main.c: 23: rx_int_chars[1] = num % 10 + '0';
      00009A 1E 05            [ 2]  206 	ldw	x, (0x05, sp)
      00009C 7B 09            [ 1]  207 	ld	a, (0x09, sp)
      00009E F7               [ 1]  208 	ld	(x), a
                                    209 ;	main.c: 24: rx_int_chars[2] ='\0';
      00009F 1E 07            [ 2]  210 	ldw	x, (0x07, sp)
      0000A1 7F               [ 1]  211 	clr	(x)
      0000A2 20 0A            [ 2]  212 	jra	00107$
      0000A4                        213 00102$:
                                    214 ;	main.c: 29: rx_int_chars[0] = num + '0';
      0000A4 7B 0B            [ 1]  215 	ld	a, (0x0b, sp)
      0000A6 AB 30            [ 1]  216 	add	a, #0x30
      0000A8 1E 01            [ 2]  217 	ldw	x, (0x01, sp)
      0000AA F7               [ 1]  218 	ld	(x), a
                                    219 ;	main.c: 30: rx_int_chars[1] ='\0';
      0000AB 1E 05            [ 2]  220 	ldw	x, (0x05, sp)
      0000AD 7F               [ 1]  221 	clr	(x)
      0000AE                        222 00107$:
                                    223 ;	main.c: 32: }
      0000AE 1E 0C            [ 2]  224 	ldw	x, (12, sp)
      0000B0 5B 0F            [ 2]  225 	addw	sp, #15
      0000B2 FC               [ 2]  226 	jp	(x)
                                    227 ;	main.c: 34: void convert_int_to_binary(int num, char* rx_binary_chars) {
                                    228 ;	-----------------------------------------
                                    229 ;	 function convert_int_to_binary
                                    230 ;	-----------------------------------------
      0000B3                        231 _convert_int_to_binary:
      0000B3 52 04            [ 2]  232 	sub	sp, #4
      0000B5 1F 01            [ 2]  233 	ldw	(0x01, sp), x
                                    234 ;	main.c: 36: for(int i = 7; i >= 0; i--) {
      0000B7 AE 00 07         [ 2]  235 	ldw	x, #0x0007
      0000BA 1F 03            [ 2]  236 	ldw	(0x03, sp), x
      0000BC                        237 00103$:
      0000BC 0D 03            [ 1]  238 	tnz	(0x03, sp)
      0000BE 2B 22            [ 1]  239 	jrmi	00101$
                                    240 ;	main.c: 38: rx_binary_chars[7 - i] = ((num >> i) & 1) + '0';
      0000C0 AE 00 07         [ 2]  241 	ldw	x, #0x0007
      0000C3 72 F0 03         [ 2]  242 	subw	x, (0x03, sp)
      0000C6 72 FB 07         [ 2]  243 	addw	x, (0x07, sp)
      0000C9 16 01            [ 2]  244 	ldw	y, (0x01, sp)
      0000CB 7B 04            [ 1]  245 	ld	a, (0x04, sp)
      0000CD 27 05            [ 1]  246 	jreq	00120$
      0000CF                        247 00119$:
      0000CF 90 57            [ 2]  248 	sraw	y
      0000D1 4A               [ 1]  249 	dec	a
      0000D2 26 FB            [ 1]  250 	jrne	00119$
      0000D4                        251 00120$:
      0000D4 90 9F            [ 1]  252 	ld	a, yl
      0000D6 A4 01            [ 1]  253 	and	a, #0x01
      0000D8 AB 30            [ 1]  254 	add	a, #0x30
      0000DA F7               [ 1]  255 	ld	(x), a
                                    256 ;	main.c: 36: for(int i = 7; i >= 0; i--) {
      0000DB 1E 03            [ 2]  257 	ldw	x, (0x03, sp)
      0000DD 5A               [ 2]  258 	decw	x
      0000DE 1F 03            [ 2]  259 	ldw	(0x03, sp), x
      0000E0 20 DA            [ 2]  260 	jra	00103$
      0000E2                        261 00101$:
                                    262 ;	main.c: 40: rx_binary_chars[8] = '\0'; // Добавляем символ конца строки
      0000E2 1E 07            [ 2]  263 	ldw	x, (0x07, sp)
      0000E4 6F 08            [ 1]  264 	clr	(0x0008, x)
                                    265 ;	main.c: 41: }
      0000E6 1E 05            [ 2]  266 	ldw	x, (5, sp)
      0000E8 5B 08            [ 2]  267 	addw	sp, #8
      0000EA FC               [ 2]  268 	jp	(x)
                                    269 ;	main.c: 46: int uart_write_line(const char *str) {
                                    270 ;	-----------------------------------------
                                    271 ;	 function uart_write_line
                                    272 ;	-----------------------------------------
      0000EB                        273 _uart_write_line:
      0000EB 52 05            [ 2]  274 	sub	sp, #5
      0000ED 1F 03            [ 2]  275 	ldw	(0x03, sp), x
                                    276 ;	main.c: 48: for(i = 0; i < strlen(str); i++) {
      0000EF 0F 05            [ 1]  277 	clr	(0x05, sp)
      0000F1                        278 00106$:
      0000F1 1E 03            [ 2]  279 	ldw	x, (0x03, sp)
      0000F3 CDr00r00         [ 4]  280 	call	_strlen
      0000F6 1F 01            [ 2]  281 	ldw	(0x01, sp), x
      0000F8 5F               [ 1]  282 	clrw	x
      0000F9 7B 05            [ 1]  283 	ld	a, (0x05, sp)
      0000FB 97               [ 1]  284 	ld	xl, a
      0000FC 13 01            [ 2]  285 	cpw	x, (0x01, sp)
      0000FE 24 14            [ 1]  286 	jrnc	00104$
                                    287 ;	main.c: 49: while(!(UART1_SR & UART_SR_TXE)); // !Transmit data register empty
      000100                        288 00101$:
      000100 C6 52 30         [ 1]  289 	ld	a, 0x5230
      000103 2A FB            [ 1]  290 	jrpl	00101$
                                    291 ;	main.c: 50: UART1_DR = str[i];
      000105 5F               [ 1]  292 	clrw	x
      000106 7B 05            [ 1]  293 	ld	a, (0x05, sp)
      000108 97               [ 1]  294 	ld	xl, a
      000109 72 FB 03         [ 2]  295 	addw	x, (0x03, sp)
      00010C F6               [ 1]  296 	ld	a, (x)
      00010D C7 52 31         [ 1]  297 	ld	0x5231, a
                                    298 ;	main.c: 48: for(i = 0; i < strlen(str); i++) {
      000110 0C 05            [ 1]  299 	inc	(0x05, sp)
      000112 20 DD            [ 2]  300 	jra	00106$
      000114                        301 00104$:
                                    302 ;	main.c: 52: return(i); // Bytes sent
      000114 7B 05            [ 1]  303 	ld	a, (0x05, sp)
      000116 5F               [ 1]  304 	clrw	x
      000117 97               [ 1]  305 	ld	xl, a
                                    306 ;	main.c: 53: }
      000118 5B 05            [ 2]  307 	addw	sp, #5
      00011A 81               [ 4]  308 	ret
                                    309 ;	main.c: 55: void status_check(void){
                                    310 ;	-----------------------------------------
                                    311 ;	 function status_check
                                    312 ;	-----------------------------------------
      00011B                        313 _status_check:
      00011B 52 09            [ 2]  314 	sub	sp, #9
                                    315 ;	main.c: 56: char rx_binary_chars[9]={0};
      00011D 0F 01            [ 1]  316 	clr	(0x01, sp)
      00011F 0F 02            [ 1]  317 	clr	(0x02, sp)
      000121 0F 03            [ 1]  318 	clr	(0x03, sp)
      000123 0F 04            [ 1]  319 	clr	(0x04, sp)
      000125 0F 05            [ 1]  320 	clr	(0x05, sp)
      000127 0F 06            [ 1]  321 	clr	(0x06, sp)
      000129 0F 07            [ 1]  322 	clr	(0x07, sp)
      00012B 0F 08            [ 1]  323 	clr	(0x08, sp)
      00012D 0F 09            [ 1]  324 	clr	(0x09, sp)
                                    325 ;	main.c: 57: convert_int_to_binary(I2C_SR1, rx_binary_chars);
      00012F 96               [ 1]  326 	ldw	x, sp
      000130 5C               [ 1]  327 	incw	x
      000131 51               [ 1]  328 	exgw	x, y
      000132 C6 52 17         [ 1]  329 	ld	a, 0x5217
      000135 5F               [ 1]  330 	clrw	x
      000136 90 89            [ 2]  331 	pushw	y
      000138 97               [ 1]  332 	ld	xl, a
      000139 CDr00rB3         [ 4]  333 	call	_convert_int_to_binary
                                    334 ;	main.c: 58: uart_write_line("SR1 -> ");
      00013C AEr00r00         [ 2]  335 	ldw	x, #(___str_0+0)
      00013F CDr00rEB         [ 4]  336 	call	_uart_write_line
                                    337 ;	main.c: 59: uart_write_line(rx_binary_chars);
      000142 96               [ 1]  338 	ldw	x, sp
      000143 5C               [ 1]  339 	incw	x
      000144 CDr00rEB         [ 4]  340 	call	_uart_write_line
                                    341 ;	main.c: 60: uart_write_line(" <-\n");
      000147 AEr00r08         [ 2]  342 	ldw	x, #(___str_1+0)
      00014A CDr00rEB         [ 4]  343 	call	_uart_write_line
                                    344 ;	main.c: 61: convert_int_to_binary(I2C_SR2, rx_binary_chars);
      00014D 96               [ 1]  345 	ldw	x, sp
      00014E 5C               [ 1]  346 	incw	x
      00014F 51               [ 1]  347 	exgw	x, y
      000150 C6 52 18         [ 1]  348 	ld	a, 0x5218
      000153 5F               [ 1]  349 	clrw	x
      000154 90 89            [ 2]  350 	pushw	y
      000156 97               [ 1]  351 	ld	xl, a
      000157 CDr00rB3         [ 4]  352 	call	_convert_int_to_binary
                                    353 ;	main.c: 62: uart_write_line("SR2 -> ");
      00015A AEr00r0D         [ 2]  354 	ldw	x, #(___str_2+0)
      00015D CDr00rEB         [ 4]  355 	call	_uart_write_line
                                    356 ;	main.c: 63: uart_write_line(rx_binary_chars);
      000160 96               [ 1]  357 	ldw	x, sp
      000161 5C               [ 1]  358 	incw	x
      000162 CDr00rEB         [ 4]  359 	call	_uart_write_line
                                    360 ;	main.c: 64: uart_write_line(" <-\n");
      000165 AEr00r08         [ 2]  361 	ldw	x, #(___str_1+0)
      000168 CDr00rEB         [ 4]  362 	call	_uart_write_line
                                    363 ;	main.c: 65: convert_int_to_binary(I2C_SR3, rx_binary_chars);
      00016B 96               [ 1]  364 	ldw	x, sp
      00016C 5C               [ 1]  365 	incw	x
      00016D 51               [ 1]  366 	exgw	x, y
      00016E C6 52 19         [ 1]  367 	ld	a, 0x5219
      000171 5F               [ 1]  368 	clrw	x
      000172 90 89            [ 2]  369 	pushw	y
      000174 97               [ 1]  370 	ld	xl, a
      000175 CDr00rB3         [ 4]  371 	call	_convert_int_to_binary
                                    372 ;	main.c: 66: uart_write_line("SR3 -> ");
      000178 AEr00r15         [ 2]  373 	ldw	x, #(___str_3+0)
      00017B CDr00rEB         [ 4]  374 	call	_uart_write_line
                                    375 ;	main.c: 67: uart_write_line(rx_binary_chars);
      00017E 96               [ 1]  376 	ldw	x, sp
      00017F 5C               [ 1]  377 	incw	x
      000180 CDr00rEB         [ 4]  378 	call	_uart_write_line
                                    379 ;	main.c: 68: uart_write_line(" <-\n");
      000183 AEr00r08         [ 2]  380 	ldw	x, #(___str_1+0)
      000186 CDr00rEB         [ 4]  381 	call	_uart_write_line
                                    382 ;	main.c: 69: convert_int_to_binary(I2C_CR1, rx_binary_chars);
      000189 96               [ 1]  383 	ldw	x, sp
      00018A 5C               [ 1]  384 	incw	x
      00018B 51               [ 1]  385 	exgw	x, y
      00018C C6 52 10         [ 1]  386 	ld	a, 0x5210
      00018F 5F               [ 1]  387 	clrw	x
      000190 90 89            [ 2]  388 	pushw	y
      000192 97               [ 1]  389 	ld	xl, a
      000193 CDr00rB3         [ 4]  390 	call	_convert_int_to_binary
                                    391 ;	main.c: 70: uart_write_line("CR1 -> ");
      000196 AEr00r1D         [ 2]  392 	ldw	x, #(___str_4+0)
      000199 CDr00rEB         [ 4]  393 	call	_uart_write_line
                                    394 ;	main.c: 71: uart_write_line(rx_binary_chars);
      00019C 96               [ 1]  395 	ldw	x, sp
      00019D 5C               [ 1]  396 	incw	x
      00019E CDr00rEB         [ 4]  397 	call	_uart_write_line
                                    398 ;	main.c: 72: uart_write_line(" <-\n");
      0001A1 AEr00r08         [ 2]  399 	ldw	x, #(___str_1+0)
      0001A4 CDr00rEB         [ 4]  400 	call	_uart_write_line
                                    401 ;	main.c: 73: convert_int_to_binary(I2C_CR2, rx_binary_chars);
      0001A7 96               [ 1]  402 	ldw	x, sp
      0001A8 5C               [ 1]  403 	incw	x
      0001A9 51               [ 1]  404 	exgw	x, y
      0001AA C6 52 11         [ 1]  405 	ld	a, 0x5211
      0001AD 5F               [ 1]  406 	clrw	x
      0001AE 90 89            [ 2]  407 	pushw	y
      0001B0 97               [ 1]  408 	ld	xl, a
      0001B1 CDr00rB3         [ 4]  409 	call	_convert_int_to_binary
                                    410 ;	main.c: 74: uart_write_line("CR2 -> ");
      0001B4 AEr00r25         [ 2]  411 	ldw	x, #(___str_5+0)
      0001B7 CDr00rEB         [ 4]  412 	call	_uart_write_line
                                    413 ;	main.c: 75: uart_write_line(rx_binary_chars);
      0001BA 96               [ 1]  414 	ldw	x, sp
      0001BB 5C               [ 1]  415 	incw	x
      0001BC CDr00rEB         [ 4]  416 	call	_uart_write_line
                                    417 ;	main.c: 76: uart_write_line(" <-\n");
      0001BF AEr00r08         [ 2]  418 	ldw	x, #(___str_1+0)
      0001C2 CDr00rEB         [ 4]  419 	call	_uart_write_line
                                    420 ;	main.c: 77: }
      0001C5 5B 09            [ 2]  421 	addw	sp, #9
      0001C7 81               [ 4]  422 	ret
                                    423 ;	main.c: 79: int main(void)
                                    424 ;	-----------------------------------------
                                    425 ;	 function main
                                    426 ;	-----------------------------------------
      0001C8                        427 _main:
      0001C8 52 05            [ 2]  428 	sub	sp, #5
                                    429 ;	main.c: 82: CLK_CKDIVR = 0;
      0001CA 35 00 50 C6      [ 1]  430 	mov	0x50c6+0, #0x00
                                    431 ;	main.c: 85: UART1_CR2 |= UART_CR2_TEN; // Transmitter enable
      0001CE 72 16 52 35      [ 1]  432 	bset	0x5235, #3
                                    433 ;	main.c: 87: UART1_CR3 &= ~(UART_CR3_STOP1 | UART_CR3_STOP2); // 1 stop bit
      0001D2 C6 52 36         [ 1]  434 	ld	a, 0x5236
      0001D5 A4 CF            [ 1]  435 	and	a, #0xcf
      0001D7 C7 52 36         [ 1]  436 	ld	0x5236, a
                                    437 ;	main.c: 89: UART1_BRR2 = 0x03; UART1_BRR1 = 0x68; // 0x0683 coded funky way (see ref manual)
      0001DA 35 03 52 33      [ 1]  438 	mov	0x5233+0, #0x03
      0001DE 35 68 52 32      [ 1]  439 	mov	0x5232+0, #0x68
                                    440 ;	main.c: 93: I2C_CR1 = I2C_CR1 & ~0x01;      // PE=0, disable I2C before setup
      0001E2 72 11 52 10      [ 1]  441 	bres	0x5210, #0
                                    442 ;	main.c: 97: I2C_CCRH = I2C_CCRH & ~0x80;    // set standart mode(100кHz)
      0001E6 72 1F 52 1C      [ 1]  443 	bres	0x521c, #7
                                    444 ;	main.c: 98: I2C_OARH = I2C_OARH & ~0x80;    // 7-bit address mode
      0001EA 72 1F 52 14      [ 1]  445 	bres	0x5214, #7
                                    446 ;	main.c: 99: I2C_OARH = I2C_OARH | 0x40;     // see reference manual
      0001EE 72 1C 52 14      [ 1]  447 	bset	0x5214, #6
                                    448 ;	main.c: 100: I2C_CR1 = I2C_CR1 | 0x01;       // PE=1, enable I2C
      0001F2 72 10 52 10      [ 1]  449 	bset	0x5210, #0
                                    450 ;	main.c: 101: status_check();
      0001F6 CDr01r1B         [ 4]  451 	call	_status_check
                                    452 ;	main.c: 106: uart_write_line("Start Scanning\n");
      0001F9 AEr00r2D         [ 2]  453 	ldw	x, #(___str_6+0)
      0001FC CDr00rEB         [ 4]  454 	call	_uart_write_line
                                    455 ;	main.c: 108: for(uint8_t addr = 0x00; addr < 0xFF;addr++)
      0001FF 0F 05            [ 1]  456 	clr	(0x05, sp)
      000201                        457 00106$:
      000201 7B 05            [ 1]  458 	ld	a, (0x05, sp)
      000203 A1 FF            [ 1]  459 	cp	a, #0xff
      000205 24 59            [ 1]  460 	jrnc	00104$
                                    461 ;	main.c: 111: uart_write_line("_______Start______\n");
      000207 AEr00r3D         [ 2]  462 	ldw	x, #(___str_7+0)
      00020A CDr00rEB         [ 4]  463 	call	_uart_write_line
                                    464 ;	main.c: 112: uart_write_line("Dev ->  ");
      00020D AEr00r51         [ 2]  465 	ldw	x, #(___str_8+0)
      000210 CDr00rEB         [ 4]  466 	call	_uart_write_line
                                    467 ;	main.c: 113: char rx_int_chars[4]={0};
      000213 0F 01            [ 1]  468 	clr	(0x01, sp)
      000215 0F 02            [ 1]  469 	clr	(0x02, sp)
      000217 0F 03            [ 1]  470 	clr	(0x03, sp)
      000219 0F 04            [ 1]  471 	clr	(0x04, sp)
                                    472 ;	main.c: 115: convert_int_to_chars(addr, rx_int_chars);
      00021B 96               [ 1]  473 	ldw	x, sp
      00021C 5C               [ 1]  474 	incw	x
      00021D 51               [ 1]  475 	exgw	x, y
      00021E 7B 05            [ 1]  476 	ld	a, (0x05, sp)
      000220 5F               [ 1]  477 	clrw	x
      000221 90 89            [ 2]  478 	pushw	y
      000223 97               [ 1]  479 	ld	xl, a
      000224 CDr00r2E         [ 4]  480 	call	_convert_int_to_chars
                                    481 ;	main.c: 116: uart_write_line(rx_int_chars);
      000227 96               [ 1]  482 	ldw	x, sp
      000228 5C               [ 1]  483 	incw	x
      000229 CDr00rEB         [ 4]  484 	call	_uart_write_line
                                    485 ;	main.c: 117: uart_write_line("  <- Dev\n");
      00022C AEr00r5A         [ 2]  486 	ldw	x, #(___str_9+0)
      00022F CDr00rEB         [ 4]  487 	call	_uart_write_line
                                    488 ;	main.c: 123: I2C_CR2 = I2C_CR2 | (1 << 2); // Set ACK bit
      000232 72 14 52 11      [ 1]  489 	bset	0x5211, #2
                                    490 ;	main.c: 126: I2C_CR2 = I2C_CR2 | (1 << 0); // START
      000236 72 10 52 11      [ 1]  491 	bset	0x5211, #0
                                    492 ;	main.c: 129: while (!(I2C_SR1 & (1 << 0)));
      00023A                        493 00101$:
      00023A 72 01 52 17 FB   [ 2]  494 	btjf	0x5217, #0, 00101$
                                    495 ;	main.c: 133: I2C_DR = I2C_DR | addr;
      00023F C6 52 16         [ 1]  496 	ld	a, 0x5216
      000242 1A 05            [ 1]  497 	or	a, (0x05, sp)
      000244 C7 52 16         [ 1]  498 	ld	0x5216, a
                                    499 ;	main.c: 140: I2C_SR1 = 0x00;
      000247 35 00 52 17      [ 1]  500 	mov	0x5217+0, #0x00
                                    501 ;	main.c: 141: I2C_SR3 = 0x00;
      00024B 35 00 52 19      [ 1]  502 	mov	0x5219+0, #0x00
                                    503 ;	main.c: 142: I2C_CR2 = I2C_CR2 | (1 << 1); // STOP
      00024F 72 12 52 11      [ 1]  504 	bset	0x5211, #1
                                    505 ;	main.c: 143: status_check();
      000253 CDr01r1B         [ 4]  506 	call	_status_check
                                    507 ;	main.c: 146: uart_write_line("_______Stop_______\n");
      000256 AEr00r64         [ 2]  508 	ldw	x, #(___str_10+0)
      000259 CDr00rEB         [ 4]  509 	call	_uart_write_line
                                    510 ;	main.c: 108: for(uint8_t addr = 0x00; addr < 0xFF;addr++)
      00025C 0C 05            [ 1]  511 	inc	(0x05, sp)
      00025E 20 A1            [ 2]  512 	jra	00106$
      000260                        513 00104$:
                                    514 ;	main.c: 152: return 0;
      000260 5F               [ 1]  515 	clrw	x
                                    516 ;	main.c: 153: }
      000261 5B 05            [ 2]  517 	addw	sp, #5
      000263 81               [ 4]  518 	ret
                                    519 	.area CODE
                                    520 	.area CONST
                                    521 	.area CONST
      000000                        522 ___str_0:
      000000 53 52 31 20 2D 3E 20   523 	.ascii "SR1 -> "
      000007 00                     524 	.db 0x00
                                    525 	.area CODE
                                    526 	.area CONST
      000008                        527 ___str_1:
      000008 20 3C 2D               528 	.ascii " <-"
      00000B 0A                     529 	.db 0x0a
      00000C 00                     530 	.db 0x00
                                    531 	.area CODE
                                    532 	.area CONST
      00000D                        533 ___str_2:
      00000D 53 52 32 20 2D 3E 20   534 	.ascii "SR2 -> "
      000014 00                     535 	.db 0x00
                                    536 	.area CODE
                                    537 	.area CONST
      000015                        538 ___str_3:
      000015 53 52 33 20 2D 3E 20   539 	.ascii "SR3 -> "
      00001C 00                     540 	.db 0x00
                                    541 	.area CODE
                                    542 	.area CONST
      00001D                        543 ___str_4:
      00001D 43 52 31 20 2D 3E 20   544 	.ascii "CR1 -> "
      000024 00                     545 	.db 0x00
                                    546 	.area CODE
                                    547 	.area CONST
      000025                        548 ___str_5:
      000025 43 52 32 20 2D 3E 20   549 	.ascii "CR2 -> "
      00002C 00                     550 	.db 0x00
                                    551 	.area CODE
                                    552 	.area CONST
      00002D                        553 ___str_6:
      00002D 53 74 61 72 74 20 53   554 	.ascii "Start Scanning"
             63 61 6E 6E 69 6E 67
      00003B 0A                     555 	.db 0x0a
      00003C 00                     556 	.db 0x00
                                    557 	.area CODE
                                    558 	.area CONST
      00003D                        559 ___str_7:
      00003D 5F 5F 5F 5F 5F 5F 5F   560 	.ascii "_______Start______"
             53 74 61 72 74 5F 5F
             5F 5F 5F 5F
      00004F 0A                     561 	.db 0x0a
      000050 00                     562 	.db 0x00
                                    563 	.area CODE
                                    564 	.area CONST
      000051                        565 ___str_8:
      000051 44 65 76 20 2D 3E 20   566 	.ascii "Dev ->  "
             20
      000059 00                     567 	.db 0x00
                                    568 	.area CODE
                                    569 	.area CONST
      00005A                        570 ___str_9:
      00005A 20 20 3C 2D 20 44 65   571 	.ascii "  <- Dev"
             76
      000062 0A                     572 	.db 0x0a
      000063 00                     573 	.db 0x00
                                    574 	.area CODE
                                    575 	.area CONST
      000064                        576 ___str_10:
      000064 5F 5F 5F 5F 5F 5F 5F   577 	.ascii "_______Stop_______"
             53 74 6F 70 5F 5F 5F
             5F 5F 5F 5F
      000076 0A                     578 	.db 0x0a
      000077 00                     579 	.db 0x00
                                    580 	.area CODE
                                    581 	.area INITIALIZER
                                    582 	.area CABS (ABS)
