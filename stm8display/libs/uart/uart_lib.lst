                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.4.0 #14620 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module uart_lib
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _buf_size
                                     12 	.globl _buf_pos
                                     13 	.globl _rx_buf_pointer
                                     14 	.globl _tx_buf_pointer
                                     15 	.globl _uart_transmission_irq
                                     16 	.globl _uart_reciever_irq
                                     17 	.globl _uart_write_irq
                                     18 	.globl _uart_read_irq
                                     19 	.globl _uart_init
                                     20 	.globl _uart_read_byte
                                     21 	.globl _uart_write_byte
                                     22 	.globl _uart_write
                                     23 	.globl _uart_read
                                     24 ;--------------------------------------------------------
                                     25 ; ram data
                                     26 ;--------------------------------------------------------
                                     27 	.area DATA
      000000                         28 _tx_buf_pointer::
      000000                         29 	.ds 2
      000002                         30 _rx_buf_pointer::
      000002                         31 	.ds 2
      000004                         32 _buf_pos::
      000004                         33 	.ds 1
      000005                         34 _buf_size::
      000005                         35 	.ds 1
                                     36 ;--------------------------------------------------------
                                     37 ; ram data
                                     38 ;--------------------------------------------------------
                                     39 	.area INITIALIZED
                                     40 ;--------------------------------------------------------
                                     41 ; absolute external ram data
                                     42 ;--------------------------------------------------------
                                     43 	.area DABS (ABS)
                                     44 
                                     45 ; default segment ordering for linker
                                     46 	.area HOME
                                     47 	.area GSINIT
                                     48 	.area GSFINAL
                                     49 	.area CONST
                                     50 	.area INITIALIZER
                                     51 	.area CODE
                                     52 
                                     53 ;--------------------------------------------------------
                                     54 ; global & static initialisations
                                     55 ;--------------------------------------------------------
                                     56 	.area HOME
                                     57 	.area GSINIT
                                     58 	.area GSFINAL
                                     59 	.area GSINIT
                                     60 ;--------------------------------------------------------
                                     61 ; Home
                                     62 ;--------------------------------------------------------
                                     63 	.area HOME
                                     64 	.area HOME
                                     65 ;--------------------------------------------------------
                                     66 ; code
                                     67 ;--------------------------------------------------------
                                     68 	.area CODE
                                     69 ;	uart_lib.c: 3: void uart_transmission_irq(void) __interrupt(UART1_T_vector)
                                     70 ;	-----------------------------------------
                                     71 ;	 function uart_transmission_irq
                                     72 ;	-----------------------------------------
      000000                         73 _uart_transmission_irq:
                                     74 ;	uart_lib.c: 5: if(UART1_SR -> TXE) 
      000000 AE 52 30         [ 2]   75 	ldw	x, #0x5230
      000003 F6               [ 1]   76 	ld	a, (x)
      000004 4E               [ 1]   77 	swap	a
      000005 44               [ 1]   78 	srl	a
      000006 44               [ 1]   79 	srl	a
      000007 44               [ 1]   80 	srl	a
      000008 A5 01            [ 1]   81 	bcp	a, #0x01
      00000A 27 2F            [ 1]   82 	jreq	00107$
                                     83 ;	uart_lib.c: 7: if(tx_buf_pointer[buf_pos] != '\0' && buf_size>buf_pos)
      00000C C6u00u01         [ 1]   84 	ld	a, _tx_buf_pointer+1
      00000F CBu00u04         [ 1]   85 	add	a, _buf_pos+0
      000012 97               [ 1]   86 	ld	xl, a
      000013 C6u00u00         [ 1]   87 	ld	a, _tx_buf_pointer+0
      000016 A9 00            [ 1]   88 	adc	a, #0x00
      000018 95               [ 1]   89 	ld	xh, a
      000019 F6               [ 1]   90 	ld	a, (x)
      00001A 27 1B            [ 1]   91 	jreq	00102$
      00001C C6u00u04         [ 1]   92 	ld	a, _buf_pos+0
      00001F C1u00u05         [ 1]   93 	cp	a, _buf_size+0
      000022 24 13            [ 1]   94 	jrnc	00102$
                                     95 ;	uart_lib.c: 8: UART1_DR -> DR = tx_buf_pointer[buf_pos++];
      000024 C6u00u04         [ 1]   96 	ld	a, _buf_pos+0
      000027 72 5Cu00u04      [ 1]   97 	inc	_buf_pos+0
      00002B 5F               [ 1]   98 	clrw	x
      00002C 97               [ 1]   99 	ld	xl, a
      00002D 72 BBu00u00      [ 2]  100 	addw	x, _tx_buf_pointer+0
      000031 F6               [ 1]  101 	ld	a, (x)
      000032 C7 52 31         [ 1]  102 	ld	0x5231, a
      000035 20 04            [ 2]  103 	jra	00107$
      000037                        104 00102$:
                                    105 ;	uart_lib.c: 10: UART1_CR2 -> TIEN = 0;
      000037 72 1F 52 35      [ 1]  106 	bres	0x5235, #7
      00003B                        107 00107$:
                                    108 ;	uart_lib.c: 14: }
      00003B 80               [11]  109 	iret
                                    110 ;	uart_lib.c: 16: void uart_reciever_irq(void) __interrupt(UART1_R_vector)
                                    111 ;	-----------------------------------------
                                    112 ;	 function uart_reciever_irq
                                    113 ;	-----------------------------------------
      00003C                        114 _uart_reciever_irq:
      00003C 88               [ 1]  115 	push	a
                                    116 ;	uart_lib.c: 20: if(UART1_SR -> RXNE)
      00003D C6 52 30         [ 1]  117 	ld	a, 0x5230
      000040 4E               [ 1]  118 	swap	a
      000041 44               [ 1]  119 	srl	a
      000042 A5 01            [ 1]  120 	bcp	a, #0x01
      000044 27 27            [ 1]  121 	jreq	00107$
                                    122 ;	uart_lib.c: 22: trash_reg = UART1_DR -> DR;
      000046 C6 52 31         [ 1]  123 	ld	a, 0x5231
                                    124 ;	uart_lib.c: 23: if(trash_reg != '\n' && buf_size>buf_pos)
      000049 6B 01            [ 1]  125 	ld	(0x01, sp), a
      00004B A1 0A            [ 1]  126 	cp	a, #0x0a
      00004D 27 1A            [ 1]  127 	jreq	00102$
      00004F C6u00u04         [ 1]  128 	ld	a, _buf_pos+0
      000052 C1u00u05         [ 1]  129 	cp	a, _buf_size+0
      000055 24 12            [ 1]  130 	jrnc	00102$
                                    131 ;	uart_lib.c: 24: rx_buf_pointer[buf_pos++] = trash_reg;
      000057 C6u00u04         [ 1]  132 	ld	a, _buf_pos+0
      00005A 72 5Cu00u04      [ 1]  133 	inc	_buf_pos+0
      00005E 5F               [ 1]  134 	clrw	x
      00005F 97               [ 1]  135 	ld	xl, a
      000060 72 BBu00u02      [ 2]  136 	addw	x, _rx_buf_pointer+0
      000064 7B 01            [ 1]  137 	ld	a, (0x01, sp)
      000066 F7               [ 1]  138 	ld	(x), a
      000067 20 04            [ 2]  139 	jra	00107$
      000069                        140 00102$:
                                    141 ;	uart_lib.c: 26: UART1_CR2 -> RIEN = 0;
      000069 72 1B 52 35      [ 1]  142 	bres	0x5235, #5
      00006D                        143 00107$:
                                    144 ;	uart_lib.c: 30: }
      00006D 84               [ 1]  145 	pop	a
      00006E 80               [11]  146 	iret
                                    147 ;	uart_lib.c: 32: void uart_write_irq(uint8_t *data_buf)
                                    148 ;	-----------------------------------------
                                    149 ;	 function uart_write_irq
                                    150 ;	-----------------------------------------
      00006F                        151 _uart_write_irq:
      00006F 52 02            [ 2]  152 	sub	sp, #2
                                    153 ;	uart_lib.c: 34: tx_buf_pointer = data_buf;
      000071 1F 01            [ 2]  154 	ldw	(0x01, sp), x
      000073 CFu00u00         [ 2]  155 	ldw	_tx_buf_pointer+0, x
                                    156 ;	uart_lib.c: 35: buf_pos = 0;
      000076 72 5Fu00u04      [ 1]  157 	clr	_buf_pos+0
                                    158 ;	uart_lib.c: 36: buf_size = 0;
      00007A 72 5Fu00u05      [ 1]  159 	clr	_buf_size+0
                                    160 ;	uart_lib.c: 37: while (data_buf[buf_size++] != '\0');
      00007E                        161 00101$:
      00007E C6u00u05         [ 1]  162 	ld	a, _buf_size+0
      000081 72 5Cu00u05      [ 1]  163 	inc	_buf_size+0
      000085 5F               [ 1]  164 	clrw	x
      000086 97               [ 1]  165 	ld	xl, a
      000087 72 FB 01         [ 2]  166 	addw	x, (0x01, sp)
      00008A F6               [ 1]  167 	ld	a, (x)
      00008B 26 F1            [ 1]  168 	jrne	00101$
                                    169 ;	uart_lib.c: 38: UART1_CR2 -> TIEN = 1;
      00008D 72 1E 52 35      [ 1]  170 	bset	0x5235, #7
                                    171 ;	uart_lib.c: 39: while(UART1_CR2 -> TIEN);
      000091                        172 00104$:
      000091 72 0E 52 35 FB   [ 2]  173 	btjt	0x5235, #7, 00104$
                                    174 ;	uart_lib.c: 40: }
      000096 5B 02            [ 2]  175 	addw	sp, #2
      000098 81               [ 4]  176 	ret
                                    177 ;	uart_lib.c: 41: void uart_read_irq(uint8_t *data_buf,int size)
                                    178 ;	-----------------------------------------
                                    179 ;	 function uart_read_irq
                                    180 ;	-----------------------------------------
      000099                        181 _uart_read_irq:
                                    182 ;	uart_lib.c: 43: rx_buf_pointer = data_buf;
      000099 CFu00u02         [ 2]  183 	ldw	_rx_buf_pointer+0, x
                                    184 ;	uart_lib.c: 44: buf_pos = 0;
      00009C 72 5Fu00u04      [ 1]  185 	clr	_buf_pos+0
                                    186 ;	uart_lib.c: 45: buf_size = size;
      0000A0 7B 04            [ 1]  187 	ld	a, (0x04, sp)
      0000A2 C7u00u05         [ 1]  188 	ld	_buf_size+0, a
                                    189 ;	uart_lib.c: 46: UART1_CR2 -> RIEN = 1;
      0000A5 72 1A 52 35      [ 1]  190 	bset	0x5235, #5
                                    191 ;	uart_lib.c: 47: while(UART1_CR2 -> RIEN);
      0000A9                        192 00101$:
      0000A9 C6 52 35         [ 1]  193 	ld	a, 0x5235
      0000AC 4E               [ 1]  194 	swap	a
      0000AD 44               [ 1]  195 	srl	a
      0000AE A4 01            [ 1]  196 	and	a, #0x01
      0000B0 26 F7            [ 1]  197 	jrne	00101$
                                    198 ;	uart_lib.c: 48: }
      0000B2 1E 01            [ 2]  199 	ldw	x, (1, sp)
      0000B4 5B 04            [ 2]  200 	addw	sp, #4
      0000B6 FC               [ 2]  201 	jp	(x)
                                    202 ;	uart_lib.c: 50: void uart_init(unsigned int baudrate,uint8_t stopbit)
                                    203 ;	-----------------------------------------
                                    204 ;	 function uart_init
                                    205 ;	-----------------------------------------
      0000B7                        206 _uart_init:
      0000B7 52 02            [ 2]  207 	sub	sp, #2
      0000B9 1F 01            [ 2]  208 	ldw	(0x01, sp), x
                                    209 ;	uart_lib.c: 54: UART1_CR2 -> TEN = 1; // Transmitter enable
      0000BB AE 52 35         [ 2]  210 	ldw	x, #0x5235
      0000BE 88               [ 1]  211 	push	a
      0000BF F6               [ 1]  212 	ld	a, (x)
      0000C0 AA 08            [ 1]  213 	or	a, #0x08
      0000C2 F7               [ 1]  214 	ld	(x), a
      0000C3 84               [ 1]  215 	pop	a
                                    216 ;	uart_lib.c: 55: UART1_CR2 -> REN = 1; // Receiver enable
      0000C4 AE 52 35         [ 2]  217 	ldw	x, #0x5235
      0000C7 88               [ 1]  218 	push	a
      0000C8 F6               [ 1]  219 	ld	a, (x)
      0000C9 AA 04            [ 1]  220 	or	a, #0x04
      0000CB F7               [ 1]  221 	ld	(x), a
      0000CC 84               [ 1]  222 	pop	a
                                    223 ;	uart_lib.c: 56: switch(stopbit)
      0000CD A1 02            [ 1]  224 	cp	a, #0x02
      0000CF 27 06            [ 1]  225 	jreq	00101$
      0000D1 A1 03            [ 1]  226 	cp	a, #0x03
      0000D3 27 0E            [ 1]  227 	jreq	00102$
      0000D5 20 16            [ 2]  228 	jra	00103$
                                    229 ;	uart_lib.c: 58: case 2:
      0000D7                        230 00101$:
                                    231 ;	uart_lib.c: 59: UART1_CR3 -> STOP = 2;
      0000D7 C6 52 36         [ 1]  232 	ld	a, 0x5236
      0000DA A4 CF            [ 1]  233 	and	a, #0xcf
      0000DC AA 20            [ 1]  234 	or	a, #0x20
      0000DE C7 52 36         [ 1]  235 	ld	0x5236, a
                                    236 ;	uart_lib.c: 60: break;
      0000E1 20 12            [ 2]  237 	jra	00104$
                                    238 ;	uart_lib.c: 61: case 3:
      0000E3                        239 00102$:
                                    240 ;	uart_lib.c: 62: UART1_CR3 -> STOP = 3;
      0000E3 C6 52 36         [ 1]  241 	ld	a, 0x5236
      0000E6 AA 30            [ 1]  242 	or	a, #0x30
      0000E8 C7 52 36         [ 1]  243 	ld	0x5236, a
                                    244 ;	uart_lib.c: 63: break;
      0000EB 20 08            [ 2]  245 	jra	00104$
                                    246 ;	uart_lib.c: 64: default:
      0000ED                        247 00103$:
                                    248 ;	uart_lib.c: 65: UART1_CR3 -> STOP = 0;
      0000ED C6 52 36         [ 1]  249 	ld	a, 0x5236
      0000F0 A4 CF            [ 1]  250 	and	a, #0xcf
      0000F2 C7 52 36         [ 1]  251 	ld	0x5236, a
                                    252 ;	uart_lib.c: 67: }
      0000F5                        253 00104$:
                                    254 ;	uart_lib.c: 68: switch(baudrate)
      0000F5 1E 01            [ 2]  255 	ldw	x, (0x01, sp)
      0000F7 A3 08 00         [ 2]  256 	cpw	x, #0x0800
      0000FA 26 03            [ 1]  257 	jrne	00186$
      0000FC CCr01r88         [ 2]  258 	jp	00110$
      0000FF                        259 00186$:
      0000FF 1E 01            [ 2]  260 	ldw	x, (0x01, sp)
      000101 A3 09 60         [ 2]  261 	cpw	x, #0x0960
      000104 27 28            [ 1]  262 	jreq	00105$
      000106 1E 01            [ 2]  263 	ldw	x, (0x01, sp)
      000108 A3 10 00         [ 2]  264 	cpw	x, #0x1000
      00010B 26 03            [ 1]  265 	jrne	00192$
      00010D CCr01r98         [ 2]  266 	jp	00111$
      000110                        267 00192$:
      000110 1E 01            [ 2]  268 	ldw	x, (0x01, sp)
      000112 A3 4B 00         [ 2]  269 	cpw	x, #0x4b00
      000115 27 31            [ 1]  270 	jreq	00106$
      000117 1E 01            [ 2]  271 	ldw	x, (0x01, sp)
      000119 A3 84 00         [ 2]  272 	cpw	x, #0x8400
      00011C 27 5A            [ 1]  273 	jreq	00109$
      00011E 1E 01            [ 2]  274 	ldw	x, (0x01, sp)
      000120 A3 C2 00         [ 2]  275 	cpw	x, #0xc200
      000123 27 43            [ 1]  276 	jreq	00108$
      000125 1E 01            [ 2]  277 	ldw	x, (0x01, sp)
      000127 A3 E1 00         [ 2]  278 	cpw	x, #0xe100
      00012A 27 2C            [ 1]  279 	jreq	00107$
      00012C 20 7A            [ 2]  280 	jra	00112$
                                    281 ;	uart_lib.c: 70: case (unsigned int)2400:
      00012E                        282 00105$:
                                    283 ;	uart_lib.c: 71: UART1_BRR2 -> MSB = 0x01;
      00012E C6 52 33         [ 1]  284 	ld	a, 0x5233
      000131 A4 0F            [ 1]  285 	and	a, #0x0f
      000133 AA 10            [ 1]  286 	or	a, #0x10
      000135 C7 52 33         [ 1]  287 	ld	0x5233, a
                                    288 ;	uart_lib.c: 72: UART1_BRR1 -> DIV = 0xA0;
      000138 35 A0 52 32      [ 1]  289 	mov	0x5232+0, #0xa0
                                    290 ;	uart_lib.c: 73: UART1_BRR2 -> LSB = 0x0B; 
      00013C C6 52 33         [ 1]  291 	ld	a, 0x5233
      00013F A4 F0            [ 1]  292 	and	a, #0xf0
      000141 AA 0B            [ 1]  293 	or	a, #0x0b
      000143 C7 52 33         [ 1]  294 	ld	0x5233, a
                                    295 ;	uart_lib.c: 74: break;
      000146 20 6E            [ 2]  296 	jra	00114$
                                    297 ;	uart_lib.c: 75: case (unsigned int)19200:
      000148                        298 00106$:
                                    299 ;	uart_lib.c: 76: UART1_BRR1 -> DIV = 0x34;
      000148 35 34 52 32      [ 1]  300 	mov	0x5232+0, #0x34
                                    301 ;	uart_lib.c: 77: UART1_BRR2 -> LSB = 0x01;
      00014C C6 52 33         [ 1]  302 	ld	a, 0x5233
      00014F A4 F0            [ 1]  303 	and	a, #0xf0
      000151 AA 01            [ 1]  304 	or	a, #0x01
      000153 C7 52 33         [ 1]  305 	ld	0x5233, a
                                    306 ;	uart_lib.c: 78: break;
      000156 20 5E            [ 2]  307 	jra	00114$
                                    308 ;	uart_lib.c: 79: case (unsigned int)57600:
      000158                        309 00107$:
                                    310 ;	uart_lib.c: 80: UART1_BRR1 -> DIV = 0x11;
      000158 35 11 52 32      [ 1]  311 	mov	0x5232+0, #0x11
                                    312 ;	uart_lib.c: 81: UART1_BRR2 -> LSB = 0x06;
      00015C C6 52 33         [ 1]  313 	ld	a, 0x5233
      00015F A4 F0            [ 1]  314 	and	a, #0xf0
      000161 AA 06            [ 1]  315 	or	a, #0x06
      000163 C7 52 33         [ 1]  316 	ld	0x5233, a
                                    317 ;	uart_lib.c: 82: break;
      000166 20 4E            [ 2]  318 	jra	00114$
                                    319 ;	uart_lib.c: 83: case (unsigned int)115200:
      000168                        320 00108$:
                                    321 ;	uart_lib.c: 84: UART1_BRR1 -> DIV = 0x08;
      000168 35 08 52 32      [ 1]  322 	mov	0x5232+0, #0x08
                                    323 ;	uart_lib.c: 85: UART1_BRR2 -> LSB = 0x0B;
      00016C C6 52 33         [ 1]  324 	ld	a, 0x5233
      00016F A4 F0            [ 1]  325 	and	a, #0xf0
      000171 AA 0B            [ 1]  326 	or	a, #0x0b
      000173 C7 52 33         [ 1]  327 	ld	0x5233, a
                                    328 ;	uart_lib.c: 86: break;
      000176 20 3E            [ 2]  329 	jra	00114$
                                    330 ;	uart_lib.c: 87: case (unsigned int)230400:
      000178                        331 00109$:
                                    332 ;	uart_lib.c: 88: UART1_BRR1 -> DIV = 0x04;
      000178 35 04 52 32      [ 1]  333 	mov	0x5232+0, #0x04
                                    334 ;	uart_lib.c: 89: UART1_BRR2 -> LSB = 0x05;
      00017C C6 52 33         [ 1]  335 	ld	a, 0x5233
      00017F A4 F0            [ 1]  336 	and	a, #0xf0
      000181 AA 05            [ 1]  337 	or	a, #0x05
      000183 C7 52 33         [ 1]  338 	ld	0x5233, a
                                    339 ;	uart_lib.c: 90: break;
      000186 20 2E            [ 2]  340 	jra	00114$
                                    341 ;	uart_lib.c: 91: case (unsigned int)460800:
      000188                        342 00110$:
                                    343 ;	uart_lib.c: 92: UART1_BRR1 -> DIV = 0x02;
      000188 35 02 52 32      [ 1]  344 	mov	0x5232+0, #0x02
                                    345 ;	uart_lib.c: 93: UART1_BRR2 -> LSB = 0x03;
      00018C C6 52 33         [ 1]  346 	ld	a, 0x5233
      00018F A4 F0            [ 1]  347 	and	a, #0xf0
      000191 AA 03            [ 1]  348 	or	a, #0x03
      000193 C7 52 33         [ 1]  349 	ld	0x5233, a
                                    350 ;	uart_lib.c: 94: break;
      000196 20 1E            [ 2]  351 	jra	00114$
                                    352 ;	uart_lib.c: 95: case (unsigned int)921600:
      000198                        353 00111$:
                                    354 ;	uart_lib.c: 96: UART1_BRR1 -> DIV = 0x01;
      000198 35 01 52 32      [ 1]  355 	mov	0x5232+0, #0x01
                                    356 ;	uart_lib.c: 97: UART1_BRR2 -> LSB = 0x01;
      00019C C6 52 33         [ 1]  357 	ld	a, 0x5233
      00019F A4 F0            [ 1]  358 	and	a, #0xf0
      0001A1 AA 01            [ 1]  359 	or	a, #0x01
      0001A3 C7 52 33         [ 1]  360 	ld	0x5233, a
                                    361 ;	uart_lib.c: 98: break;
      0001A6 20 0E            [ 2]  362 	jra	00114$
                                    363 ;	uart_lib.c: 99: default:
      0001A8                        364 00112$:
                                    365 ;	uart_lib.c: 100: UART1_BRR1 -> DIV = 0x68;
      0001A8 35 68 52 32      [ 1]  366 	mov	0x5232+0, #0x68
                                    367 ;	uart_lib.c: 101: UART1_BRR2 -> LSB = 0x03;
      0001AC C6 52 33         [ 1]  368 	ld	a, 0x5233
      0001AF A4 F0            [ 1]  369 	and	a, #0xf0
      0001B1 AA 03            [ 1]  370 	or	a, #0x03
      0001B3 C7 52 33         [ 1]  371 	ld	0x5233, a
                                    372 ;	uart_lib.c: 103: }
      0001B6                        373 00114$:
                                    374 ;	uart_lib.c: 104: }
      0001B6 5B 02            [ 2]  375 	addw	sp, #2
      0001B8 81               [ 4]  376 	ret
                                    377 ;	uart_lib.c: 106: int uart_read_byte(uint8_t *data)
                                    378 ;	-----------------------------------------
                                    379 ;	 function uart_read_byte
                                    380 ;	-----------------------------------------
      0001B9                        381 _uart_read_byte:
                                    382 ;	uart_lib.c: 108: while(!(UART1_SR -> RXNE));
      0001B9                        383 00101$:
      0001B9 72 0B 52 30 FB   [ 2]  384 	btjf	0x5230, #5, 00101$
                                    385 ;	uart_lib.c: 110: return 1;
      0001BE 5F               [ 1]  386 	clrw	x
      0001BF 5C               [ 1]  387 	incw	x
                                    388 ;	uart_lib.c: 111: }
      0001C0 81               [ 4]  389 	ret
                                    390 ;	uart_lib.c: 113: int uart_write_byte(uint8_t data)
                                    391 ;	-----------------------------------------
                                    392 ;	 function uart_write_byte
                                    393 ;	-----------------------------------------
      0001C1                        394 _uart_write_byte:
                                    395 ;	uart_lib.c: 115: UART1_DR -> DR = data;
      0001C1 C7 52 31         [ 1]  396 	ld	0x5231, a
                                    397 ;	uart_lib.c: 116: while(!(UART1_SR -> TXE));
      0001C4                        398 00101$:
      0001C4 72 0F 52 30 FB   [ 2]  399 	btjf	0x5230, #7, 00101$
                                    400 ;	uart_lib.c: 117: return 1;
      0001C9 5F               [ 1]  401 	clrw	x
      0001CA 5C               [ 1]  402 	incw	x
                                    403 ;	uart_lib.c: 118: }
      0001CB 81               [ 4]  404 	ret
                                    405 ;	uart_lib.c: 120: int uart_write(uint8_t *data_buf)
                                    406 ;	-----------------------------------------
                                    407 ;	 function uart_write
                                    408 ;	-----------------------------------------
      0001CC                        409 _uart_write:
      0001CC 52 04            [ 2]  410 	sub	sp, #4
      0001CE 1F 01            [ 2]  411 	ldw	(0x01, sp), x
                                    412 ;	uart_lib.c: 122: int count = 0;
      0001D0 5F               [ 1]  413 	clrw	x
      0001D1 1F 03            [ 2]  414 	ldw	(0x03, sp), x
                                    415 ;	uart_lib.c: 123: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      0001D3 5F               [ 1]  416 	clrw	x
      0001D4                        417 00103$:
      0001D4 90 93            [ 1]  418 	ldw	y, x
      0001D6 72 F9 01         [ 2]  419 	addw	y, (0x01, sp)
      0001D9 90 F6            [ 1]  420 	ld	a, (y)
      0001DB 27 0E            [ 1]  421 	jreq	00101$
                                    422 ;	uart_lib.c: 124: count += uart_write_byte(data_buf[i]);
      0001DD 89               [ 2]  423 	pushw	x
      0001DE CDr01rC1         [ 4]  424 	call	_uart_write_byte
      0001E1 51               [ 1]  425 	exgw	x, y
      0001E2 85               [ 2]  426 	popw	x
      0001E3 72 F9 03         [ 2]  427 	addw	y, (0x03, sp)
      0001E6 17 03            [ 2]  428 	ldw	(0x03, sp), y
                                    429 ;	uart_lib.c: 123: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      0001E8 5C               [ 1]  430 	incw	x
      0001E9 20 E9            [ 2]  431 	jra	00103$
      0001EB                        432 00101$:
                                    433 ;	uart_lib.c: 125: return count;
      0001EB 1E 03            [ 2]  434 	ldw	x, (0x03, sp)
                                    435 ;	uart_lib.c: 126: }
      0001ED 5B 04            [ 2]  436 	addw	sp, #4
      0001EF 81               [ 4]  437 	ret
                                    438 ;	uart_lib.c: 127: int uart_read(uint8_t *data_buf,int size)
                                    439 ;	-----------------------------------------
                                    440 ;	 function uart_read
                                    441 ;	-----------------------------------------
      0001F0                        442 _uart_read:
      0001F0 52 04            [ 2]  443 	sub	sp, #4
      0001F2 1F 01            [ 2]  444 	ldw	(0x01, sp), x
                                    445 ;	uart_lib.c: 130: int count = 0;
      0001F4 5F               [ 1]  446 	clrw	x
      0001F5 1F 03            [ 2]  447 	ldw	(0x03, sp), x
                                    448 ;	uart_lib.c: 131: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      0001F7 5F               [ 1]  449 	clrw	x
      0001F8                        450 00103$:
      0001F8 90 93            [ 1]  451 	ldw	y, x
      0001FA 72 F9 01         [ 2]  452 	addw	y, (0x01, sp)
      0001FD 90 F6            [ 1]  453 	ld	a, (y)
      0001FF 27 13            [ 1]  454 	jreq	00101$
                                    455 ;	uart_lib.c: 132: count += uart_read_byte((unsigned char *)data_buf[i]);
      000201 90 5F            [ 1]  456 	clrw	y
      000203 90 97            [ 1]  457 	ld	yl, a
      000205 89               [ 2]  458 	pushw	x
      000206 93               [ 1]  459 	ldw	x, y
      000207 CDr01rB9         [ 4]  460 	call	_uart_read_byte
      00020A 51               [ 1]  461 	exgw	x, y
      00020B 85               [ 2]  462 	popw	x
      00020C 72 F9 03         [ 2]  463 	addw	y, (0x03, sp)
      00020F 17 03            [ 2]  464 	ldw	(0x03, sp), y
                                    465 ;	uart_lib.c: 131: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      000211 5C               [ 1]  466 	incw	x
      000212 20 E4            [ 2]  467 	jra	00103$
      000214                        468 00101$:
                                    469 ;	uart_lib.c: 133: return count;
      000214 1E 03            [ 2]  470 	ldw	x, (0x03, sp)
                                    471 ;	uart_lib.c: 134: }
      000216 5B 04            [ 2]  472 	addw	sp, #4
      000218 90 85            [ 2]  473 	popw	y
      00021A 5B 02            [ 2]  474 	addw	sp, #2
      00021C 90 FC            [ 2]  475 	jp	(y)
                                    476 	.area CODE
                                    477 	.area CONST
                                    478 	.area INITIALIZER
                                    479 	.area CABS (ABS)
