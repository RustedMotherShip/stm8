                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.4.0 #14620 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _i2c_scan
                                     13 	.globl _i2c_read
                                     14 	.globl _i2c_write
                                     15 	.globl _i2c_send_address
                                     16 	.globl _i2c_stop
                                     17 	.globl _i2c_read_byte
                                     18 	.globl _i2c_send_byte
                                     19 	.globl _i2c_start
                                     20 	.globl _i2c_init
                                     21 	.globl _trash_clean
                                     22 	.globl _delay
                                     23 	.globl _uart_read
                                     24 	.globl _uart_write
                                     25 	.globl _uart_write_byte
                                     26 	.globl _uart_read_byte
                                     27 	.globl _uart_init
                                     28 ;--------------------------------------------------------
                                     29 ; ram data
                                     30 ;--------------------------------------------------------
                                     31 	.area DATA
                                     32 ;--------------------------------------------------------
                                     33 ; ram data
                                     34 ;--------------------------------------------------------
                                     35 	.area INITIALIZED
                                     36 ;--------------------------------------------------------
                                     37 ; Stack segment in internal ram
                                     38 ;--------------------------------------------------------
                                     39 	.area SSEG
      000000                         40 __start__stack:
      000000                         41 	.ds	1
                                     42 
                                     43 ;--------------------------------------------------------
                                     44 ; absolute external ram data
                                     45 ;--------------------------------------------------------
                                     46 	.area DABS (ABS)
                                     47 
                                     48 ; default segment ordering for linker
                                     49 	.area HOME
                                     50 	.area GSINIT
                                     51 	.area GSFINAL
                                     52 	.area CONST
                                     53 	.area INITIALIZER
                                     54 	.area CODE
                                     55 
                                     56 ;--------------------------------------------------------
                                     57 ; interrupt vector
                                     58 ;--------------------------------------------------------
                                     59 	.area HOME
      000000                         60 __interrupt_vect:
      000000 82v00u00u00             61 	int s_GSINIT ; reset
                                     62 ;--------------------------------------------------------
                                     63 ; global & static initialisations
                                     64 ;--------------------------------------------------------
                                     65 	.area HOME
                                     66 	.area GSINIT
                                     67 	.area GSFINAL
                                     68 	.area GSINIT
      000000 CDr00r00         [ 4]   69 	call	___sdcc_external_startup
      000003 4D               [ 1]   70 	tnz	a
      000004 27 03            [ 1]   71 	jreq	__sdcc_init_data
      000006 CCr00r04         [ 2]   72 	jp	__sdcc_program_startup
      000009                         73 __sdcc_init_data:
                                     74 ; stm8_genXINIT() start
      000009 AEr00r00         [ 2]   75 	ldw x, #l_DATA
      00000C 27 07            [ 1]   76 	jreq	00002$
      00000E                         77 00001$:
      00000E 72 4FuFFuFF      [ 1]   78 	clr (s_DATA - 1, x)
      000012 5A               [ 2]   79 	decw x
      000013 26 F9            [ 1]   80 	jrne	00001$
      000015                         81 00002$:
      000015 AEr00r00         [ 2]   82 	ldw	x, #l_INITIALIZER
      000018 27 09            [ 1]   83 	jreq	00004$
      00001A                         84 00003$:
      00001A D6uFFuFF         [ 1]   85 	ld	a, (s_INITIALIZER - 1, x)
      00001D D7uFFuFF         [ 1]   86 	ld	(s_INITIALIZED - 1, x), a
      000020 5A               [ 2]   87 	decw	x
      000021 26 F7            [ 1]   88 	jrne	00003$
      000023                         89 00004$:
                                     90 ; stm8_genXINIT() end
                                     91 	.area GSFINAL
      000000 CCr00r04         [ 2]   92 	jp	__sdcc_program_startup
                                     93 ;--------------------------------------------------------
                                     94 ; Home
                                     95 ;--------------------------------------------------------
                                     96 	.area HOME
                                     97 	.area HOME
      000004                         98 __sdcc_program_startup:
      000004 CCr02rD7         [ 2]   99 	jp	_main
                                    100 ;	return from main will return to caller
                                    101 ;--------------------------------------------------------
                                    102 ; code
                                    103 ;--------------------------------------------------------
                                    104 	.area CODE
                                    105 ;	libs/uart_lib.c: 3: void uart_init(unsigned int baudrate,uint8_t stopbit)
                                    106 ;	-----------------------------------------
                                    107 ;	 function uart_init
                                    108 ;	-----------------------------------------
      000000                        109 _uart_init:
      000000 52 02            [ 2]  110 	sub	sp, #2
      000002 1F 01            [ 2]  111 	ldw	(0x01, sp), x
                                    112 ;	libs/uart_lib.c: 7: UART1_CR2 -> TEN = 1; // Transmitter enable
      000004 AE 52 35         [ 2]  113 	ldw	x, #0x5235
      000007 88               [ 1]  114 	push	a
      000008 F6               [ 1]  115 	ld	a, (x)
      000009 AA 08            [ 1]  116 	or	a, #0x08
      00000B F7               [ 1]  117 	ld	(x), a
      00000C 84               [ 1]  118 	pop	a
                                    119 ;	libs/uart_lib.c: 8: UART1_CR2 -> REN = 1; // Receiver enable
      00000D AE 52 35         [ 2]  120 	ldw	x, #0x5235
      000010 88               [ 1]  121 	push	a
      000011 F6               [ 1]  122 	ld	a, (x)
      000012 AA 04            [ 1]  123 	or	a, #0x04
      000014 F7               [ 1]  124 	ld	(x), a
      000015 84               [ 1]  125 	pop	a
                                    126 ;	libs/uart_lib.c: 9: switch(stopbit)
      000016 A1 02            [ 1]  127 	cp	a, #0x02
      000018 27 06            [ 1]  128 	jreq	00101$
      00001A A1 03            [ 1]  129 	cp	a, #0x03
      00001C 27 0E            [ 1]  130 	jreq	00102$
      00001E 20 16            [ 2]  131 	jra	00103$
                                    132 ;	libs/uart_lib.c: 11: case 2:
      000020                        133 00101$:
                                    134 ;	libs/uart_lib.c: 12: UART1_CR3 -> STOP = 2;
      000020 C6 52 36         [ 1]  135 	ld	a, 0x5236
      000023 A4 CF            [ 1]  136 	and	a, #0xcf
      000025 AA 20            [ 1]  137 	or	a, #0x20
      000027 C7 52 36         [ 1]  138 	ld	0x5236, a
                                    139 ;	libs/uart_lib.c: 13: break;
      00002A 20 12            [ 2]  140 	jra	00104$
                                    141 ;	libs/uart_lib.c: 14: case 3:
      00002C                        142 00102$:
                                    143 ;	libs/uart_lib.c: 15: UART1_CR3 -> STOP = 3;
      00002C C6 52 36         [ 1]  144 	ld	a, 0x5236
      00002F AA 30            [ 1]  145 	or	a, #0x30
      000031 C7 52 36         [ 1]  146 	ld	0x5236, a
                                    147 ;	libs/uart_lib.c: 16: break;
      000034 20 08            [ 2]  148 	jra	00104$
                                    149 ;	libs/uart_lib.c: 17: default:
      000036                        150 00103$:
                                    151 ;	libs/uart_lib.c: 18: UART1_CR3 -> STOP = 0;
      000036 C6 52 36         [ 1]  152 	ld	a, 0x5236
      000039 A4 CF            [ 1]  153 	and	a, #0xcf
      00003B C7 52 36         [ 1]  154 	ld	0x5236, a
                                    155 ;	libs/uart_lib.c: 20: }
      00003E                        156 00104$:
                                    157 ;	libs/uart_lib.c: 21: switch(baudrate)
      00003E 1E 01            [ 2]  158 	ldw	x, (0x01, sp)
      000040 A3 08 00         [ 2]  159 	cpw	x, #0x0800
      000043 26 03            [ 1]  160 	jrne	00186$
      000045 CCr00rD1         [ 2]  161 	jp	00110$
      000048                        162 00186$:
      000048 1E 01            [ 2]  163 	ldw	x, (0x01, sp)
      00004A A3 09 60         [ 2]  164 	cpw	x, #0x0960
      00004D 27 28            [ 1]  165 	jreq	00105$
      00004F 1E 01            [ 2]  166 	ldw	x, (0x01, sp)
      000051 A3 10 00         [ 2]  167 	cpw	x, #0x1000
      000054 26 03            [ 1]  168 	jrne	00192$
      000056 CCr00rE1         [ 2]  169 	jp	00111$
      000059                        170 00192$:
      000059 1E 01            [ 2]  171 	ldw	x, (0x01, sp)
      00005B A3 4B 00         [ 2]  172 	cpw	x, #0x4b00
      00005E 27 31            [ 1]  173 	jreq	00106$
      000060 1E 01            [ 2]  174 	ldw	x, (0x01, sp)
      000062 A3 84 00         [ 2]  175 	cpw	x, #0x8400
      000065 27 5A            [ 1]  176 	jreq	00109$
      000067 1E 01            [ 2]  177 	ldw	x, (0x01, sp)
      000069 A3 C2 00         [ 2]  178 	cpw	x, #0xc200
      00006C 27 43            [ 1]  179 	jreq	00108$
      00006E 1E 01            [ 2]  180 	ldw	x, (0x01, sp)
      000070 A3 E1 00         [ 2]  181 	cpw	x, #0xe100
      000073 27 2C            [ 1]  182 	jreq	00107$
      000075 20 7A            [ 2]  183 	jra	00112$
                                    184 ;	libs/uart_lib.c: 23: case (unsigned int)2400:
      000077                        185 00105$:
                                    186 ;	libs/uart_lib.c: 24: UART1_BRR2 -> MSB = 0x01;
      000077 C6 52 33         [ 1]  187 	ld	a, 0x5233
      00007A A4 0F            [ 1]  188 	and	a, #0x0f
      00007C AA 10            [ 1]  189 	or	a, #0x10
      00007E C7 52 33         [ 1]  190 	ld	0x5233, a
                                    191 ;	libs/uart_lib.c: 25: UART1_BRR1 -> DIV = 0xA0;
      000081 35 A0 52 32      [ 1]  192 	mov	0x5232+0, #0xa0
                                    193 ;	libs/uart_lib.c: 26: UART1_BRR2 -> LSB = 0x0B; 
      000085 C6 52 33         [ 1]  194 	ld	a, 0x5233
      000088 A4 F0            [ 1]  195 	and	a, #0xf0
      00008A AA 0B            [ 1]  196 	or	a, #0x0b
      00008C C7 52 33         [ 1]  197 	ld	0x5233, a
                                    198 ;	libs/uart_lib.c: 27: break;
      00008F 20 6E            [ 2]  199 	jra	00114$
                                    200 ;	libs/uart_lib.c: 28: case (unsigned int)19200:
      000091                        201 00106$:
                                    202 ;	libs/uart_lib.c: 29: UART1_BRR1 -> DIV = 0x34;
      000091 35 34 52 32      [ 1]  203 	mov	0x5232+0, #0x34
                                    204 ;	libs/uart_lib.c: 30: UART1_BRR2 -> LSB = 0x01;
      000095 C6 52 33         [ 1]  205 	ld	a, 0x5233
      000098 A4 F0            [ 1]  206 	and	a, #0xf0
      00009A AA 01            [ 1]  207 	or	a, #0x01
      00009C C7 52 33         [ 1]  208 	ld	0x5233, a
                                    209 ;	libs/uart_lib.c: 31: break;
      00009F 20 5E            [ 2]  210 	jra	00114$
                                    211 ;	libs/uart_lib.c: 32: case (unsigned int)57600:
      0000A1                        212 00107$:
                                    213 ;	libs/uart_lib.c: 33: UART1_BRR1 -> DIV = 0x11;
      0000A1 35 11 52 32      [ 1]  214 	mov	0x5232+0, #0x11
                                    215 ;	libs/uart_lib.c: 34: UART1_BRR2 -> LSB = 0x06;
      0000A5 C6 52 33         [ 1]  216 	ld	a, 0x5233
      0000A8 A4 F0            [ 1]  217 	and	a, #0xf0
      0000AA AA 06            [ 1]  218 	or	a, #0x06
      0000AC C7 52 33         [ 1]  219 	ld	0x5233, a
                                    220 ;	libs/uart_lib.c: 35: break;
      0000AF 20 4E            [ 2]  221 	jra	00114$
                                    222 ;	libs/uart_lib.c: 36: case (unsigned int)115200:
      0000B1                        223 00108$:
                                    224 ;	libs/uart_lib.c: 37: UART1_BRR1 -> DIV = 0x08;
      0000B1 35 08 52 32      [ 1]  225 	mov	0x5232+0, #0x08
                                    226 ;	libs/uart_lib.c: 38: UART1_BRR2 -> LSB = 0x0B;
      0000B5 C6 52 33         [ 1]  227 	ld	a, 0x5233
      0000B8 A4 F0            [ 1]  228 	and	a, #0xf0
      0000BA AA 0B            [ 1]  229 	or	a, #0x0b
      0000BC C7 52 33         [ 1]  230 	ld	0x5233, a
                                    231 ;	libs/uart_lib.c: 39: break;
      0000BF 20 3E            [ 2]  232 	jra	00114$
                                    233 ;	libs/uart_lib.c: 40: case (unsigned int)230400:
      0000C1                        234 00109$:
                                    235 ;	libs/uart_lib.c: 41: UART1_BRR1 -> DIV = 0x04;
      0000C1 35 04 52 32      [ 1]  236 	mov	0x5232+0, #0x04
                                    237 ;	libs/uart_lib.c: 42: UART1_BRR2 -> LSB = 0x05;
      0000C5 C6 52 33         [ 1]  238 	ld	a, 0x5233
      0000C8 A4 F0            [ 1]  239 	and	a, #0xf0
      0000CA AA 05            [ 1]  240 	or	a, #0x05
      0000CC C7 52 33         [ 1]  241 	ld	0x5233, a
                                    242 ;	libs/uart_lib.c: 43: break;
      0000CF 20 2E            [ 2]  243 	jra	00114$
                                    244 ;	libs/uart_lib.c: 44: case (unsigned int)460800:
      0000D1                        245 00110$:
                                    246 ;	libs/uart_lib.c: 45: UART1_BRR1 -> DIV = 0x02;
      0000D1 35 02 52 32      [ 1]  247 	mov	0x5232+0, #0x02
                                    248 ;	libs/uart_lib.c: 46: UART1_BRR2 -> LSB = 0x03;
      0000D5 C6 52 33         [ 1]  249 	ld	a, 0x5233
      0000D8 A4 F0            [ 1]  250 	and	a, #0xf0
      0000DA AA 03            [ 1]  251 	or	a, #0x03
      0000DC C7 52 33         [ 1]  252 	ld	0x5233, a
                                    253 ;	libs/uart_lib.c: 47: break;
      0000DF 20 1E            [ 2]  254 	jra	00114$
                                    255 ;	libs/uart_lib.c: 48: case (unsigned int)921600:
      0000E1                        256 00111$:
                                    257 ;	libs/uart_lib.c: 49: UART1_BRR1 -> DIV = 0x01;
      0000E1 35 01 52 32      [ 1]  258 	mov	0x5232+0, #0x01
                                    259 ;	libs/uart_lib.c: 50: UART1_BRR2 -> LSB = 0x01;
      0000E5 C6 52 33         [ 1]  260 	ld	a, 0x5233
      0000E8 A4 F0            [ 1]  261 	and	a, #0xf0
      0000EA AA 01            [ 1]  262 	or	a, #0x01
      0000EC C7 52 33         [ 1]  263 	ld	0x5233, a
                                    264 ;	libs/uart_lib.c: 51: break;
      0000EF 20 0E            [ 2]  265 	jra	00114$
                                    266 ;	libs/uart_lib.c: 52: default:
      0000F1                        267 00112$:
                                    268 ;	libs/uart_lib.c: 53: UART1_BRR1 -> DIV = 0x68;
      0000F1 35 68 52 32      [ 1]  269 	mov	0x5232+0, #0x68
                                    270 ;	libs/uart_lib.c: 54: UART1_BRR2 -> LSB = 0x03;
      0000F5 C6 52 33         [ 1]  271 	ld	a, 0x5233
      0000F8 A4 F0            [ 1]  272 	and	a, #0xf0
      0000FA AA 03            [ 1]  273 	or	a, #0x03
      0000FC C7 52 33         [ 1]  274 	ld	0x5233, a
                                    275 ;	libs/uart_lib.c: 56: }
      0000FF                        276 00114$:
                                    277 ;	libs/uart_lib.c: 57: }
      0000FF 5B 02            [ 2]  278 	addw	sp, #2
      000101 81               [ 4]  279 	ret
                                    280 ;	libs/uart_lib.c: 59: int uart_read_byte(uint8_t *data)
                                    281 ;	-----------------------------------------
                                    282 ;	 function uart_read_byte
                                    283 ;	-----------------------------------------
      000102                        284 _uart_read_byte:
                                    285 ;	libs/uart_lib.c: 61: while(!(UART1_SR -> RXNE));
      000102                        286 00101$:
      000102 72 0B 52 30 FB   [ 2]  287 	btjf	0x5230, #5, 00101$
                                    288 ;	libs/uart_lib.c: 63: return 1;
      000107 5F               [ 1]  289 	clrw	x
      000108 5C               [ 1]  290 	incw	x
                                    291 ;	libs/uart_lib.c: 64: }
      000109 81               [ 4]  292 	ret
                                    293 ;	libs/uart_lib.c: 66: int uart_write_byte(uint8_t data)
                                    294 ;	-----------------------------------------
                                    295 ;	 function uart_write_byte
                                    296 ;	-----------------------------------------
      00010A                        297 _uart_write_byte:
                                    298 ;	libs/uart_lib.c: 68: UART1_DR -> DR = data;
      00010A C7 52 31         [ 1]  299 	ld	0x5231, a
                                    300 ;	libs/uart_lib.c: 69: while(!(UART1_SR -> TXE));
      00010D                        301 00101$:
      00010D 72 0F 52 30 FB   [ 2]  302 	btjf	0x5230, #7, 00101$
                                    303 ;	libs/uart_lib.c: 70: return 1;
      000112 5F               [ 1]  304 	clrw	x
      000113 5C               [ 1]  305 	incw	x
                                    306 ;	libs/uart_lib.c: 71: }
      000114 81               [ 4]  307 	ret
                                    308 ;	libs/uart_lib.c: 73: int uart_write(uint8_t *data_buf)
                                    309 ;	-----------------------------------------
                                    310 ;	 function uart_write
                                    311 ;	-----------------------------------------
      000115                        312 _uart_write:
      000115 52 04            [ 2]  313 	sub	sp, #4
      000117 1F 01            [ 2]  314 	ldw	(0x01, sp), x
                                    315 ;	libs/uart_lib.c: 75: int count = 0;
      000119 5F               [ 1]  316 	clrw	x
      00011A 1F 03            [ 2]  317 	ldw	(0x03, sp), x
                                    318 ;	libs/uart_lib.c: 76: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      00011C 5F               [ 1]  319 	clrw	x
      00011D                        320 00103$:
      00011D 90 93            [ 1]  321 	ldw	y, x
      00011F 72 F9 01         [ 2]  322 	addw	y, (0x01, sp)
      000122 90 F6            [ 1]  323 	ld	a, (y)
      000124 27 0E            [ 1]  324 	jreq	00101$
                                    325 ;	libs/uart_lib.c: 77: count += uart_write_byte(data_buf[i]);
      000126 89               [ 2]  326 	pushw	x
      000127 CDr01r0A         [ 4]  327 	call	_uart_write_byte
      00012A 51               [ 1]  328 	exgw	x, y
      00012B 85               [ 2]  329 	popw	x
      00012C 72 F9 03         [ 2]  330 	addw	y, (0x03, sp)
      00012F 17 03            [ 2]  331 	ldw	(0x03, sp), y
                                    332 ;	libs/uart_lib.c: 76: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      000131 5C               [ 1]  333 	incw	x
      000132 20 E9            [ 2]  334 	jra	00103$
      000134                        335 00101$:
                                    336 ;	libs/uart_lib.c: 78: return count;
      000134 1E 03            [ 2]  337 	ldw	x, (0x03, sp)
                                    338 ;	libs/uart_lib.c: 79: }
      000136 5B 04            [ 2]  339 	addw	sp, #4
      000138 81               [ 4]  340 	ret
                                    341 ;	libs/uart_lib.c: 80: int uart_read(uint8_t *data_buf)
                                    342 ;	-----------------------------------------
                                    343 ;	 function uart_read
                                    344 ;	-----------------------------------------
      000139                        345 _uart_read:
      000139 52 04            [ 2]  346 	sub	sp, #4
      00013B 1F 01            [ 2]  347 	ldw	(0x01, sp), x
                                    348 ;	libs/uart_lib.c: 82: int count = 0;
      00013D 5F               [ 1]  349 	clrw	x
      00013E 1F 03            [ 2]  350 	ldw	(0x03, sp), x
                                    351 ;	libs/uart_lib.c: 83: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      000140 5F               [ 1]  352 	clrw	x
      000141                        353 00103$:
      000141 90 93            [ 1]  354 	ldw	y, x
      000143 72 F9 01         [ 2]  355 	addw	y, (0x01, sp)
      000146 90 F6            [ 1]  356 	ld	a, (y)
      000148 27 13            [ 1]  357 	jreq	00101$
                                    358 ;	libs/uart_lib.c: 84: count += uart_read_byte((unsigned char *)data_buf[i]);
      00014A 90 5F            [ 1]  359 	clrw	y
      00014C 90 97            [ 1]  360 	ld	yl, a
      00014E 89               [ 2]  361 	pushw	x
      00014F 93               [ 1]  362 	ldw	x, y
      000150 CDr01r02         [ 4]  363 	call	_uart_read_byte
      000153 51               [ 1]  364 	exgw	x, y
      000154 85               [ 2]  365 	popw	x
      000155 72 F9 03         [ 2]  366 	addw	y, (0x03, sp)
      000158 17 03            [ 2]  367 	ldw	(0x03, sp), y
                                    368 ;	libs/uart_lib.c: 83: for (int i = 0; data_buf[i] != '\0'; i++) // Цикл до нулевого терминатора
      00015A 5C               [ 1]  369 	incw	x
      00015B 20 E4            [ 2]  370 	jra	00103$
      00015D                        371 00101$:
                                    372 ;	libs/uart_lib.c: 85: return count;
      00015D 1E 03            [ 2]  373 	ldw	x, (0x03, sp)
                                    374 ;	libs/uart_lib.c: 86: }
      00015F 5B 04            [ 2]  375 	addw	sp, #4
      000161 81               [ 4]  376 	ret
                                    377 ;	libs/i2c_lib.c: 10: void delay(uint16_t ticks)
                                    378 ;	-----------------------------------------
                                    379 ;	 function delay
                                    380 ;	-----------------------------------------
      000162                        381 _delay:
                                    382 ;	libs/i2c_lib.c: 12: while(ticks > 0)
      000162                        383 00101$:
      000162 5D               [ 2]  384 	tnzw	x
      000163 26 01            [ 1]  385 	jrne	00120$
      000165 81               [ 4]  386 	ret
      000166                        387 00120$:
                                    388 ;	libs/i2c_lib.c: 14: ticks-=2;
      000166 5A               [ 2]  389 	decw	x
      000167 5A               [ 2]  390 	decw	x
                                    391 ;	libs/i2c_lib.c: 15: ticks+=1;
      000168 5C               [ 1]  392 	incw	x
      000169 20 F7            [ 2]  393 	jra	00101$
                                    394 ;	libs/i2c_lib.c: 17: }
      00016B 81               [ 4]  395 	ret
                                    396 ;	libs/i2c_lib.c: 18: void trash_clean(void)
                                    397 ;	-----------------------------------------
                                    398 ;	 function trash_clean
                                    399 ;	-----------------------------------------
      00016C                        400 _trash_clean:
                                    401 ;	libs/i2c_lib.c: 24: }
      00016C 81               [ 4]  402 	ret
                                    403 ;	libs/i2c_lib.c: 25: void i2c_init(void) {
                                    404 ;	-----------------------------------------
                                    405 ;	 function i2c_init
                                    406 ;	-----------------------------------------
      00016D                        407 _i2c_init:
                                    408 ;	libs/i2c_lib.c: 28: I2C_CR1 -> PE = 0;// PE=0, disable I2C before setup
      00016D 72 11 52 10      [ 1]  409 	bres	0x5210, #0
                                    410 ;	libs/i2c_lib.c: 29: I2C_FREQR -> FREQ = 16;// peripheral frequence =16MHz
      000171 C6 52 12         [ 1]  411 	ld	a, 0x5212
      000174 A4 C0            [ 1]  412 	and	a, #0xc0
      000176 AA 10            [ 1]  413 	or	a, #0x10
      000178 C7 52 12         [ 1]  414 	ld	0x5212, a
                                    415 ;	libs/i2c_lib.c: 30: I2C_CCRH -> CCR = 0;// =0
      00017B C6 52 1C         [ 1]  416 	ld	a, 0x521c
      00017E A4 F0            [ 1]  417 	and	a, #0xf0
      000180 C7 52 1C         [ 1]  418 	ld	0x521c, a
                                    419 ;	libs/i2c_lib.c: 31: I2C_CCRL -> CCR = 80;// 100kHz for I2C
      000183 35 50 52 1B      [ 1]  420 	mov	0x521b+0, #0x50
                                    421 ;	libs/i2c_lib.c: 32: I2C_CCRH -> FS = 0;// set standart mode(100кHz)
      000187 72 1F 52 1C      [ 1]  422 	bres	0x521c, #7
                                    423 ;	libs/i2c_lib.c: 33: I2C_OARH -> ADDMODE = 0;// 7-bit address mode
      00018B 72 1F 52 14      [ 1]  424 	bres	0x5214, #7
                                    425 ;	libs/i2c_lib.c: 34: I2C_OARH -> ADDCONF = 1;// see reference manual
      00018F 72 10 52 14      [ 1]  426 	bset	0x5214, #0
                                    427 ;	libs/i2c_lib.c: 35: I2C_CR1 -> PE = 1;// PE=1, enable I2C
      000193 72 10 52 10      [ 1]  428 	bset	0x5210, #0
                                    429 ;	libs/i2c_lib.c: 36: }
      000197 81               [ 4]  430 	ret
                                    431 ;	libs/i2c_lib.c: 38: void i2c_start(void) {
                                    432 ;	-----------------------------------------
                                    433 ;	 function i2c_start
                                    434 ;	-----------------------------------------
      000198                        435 _i2c_start:
                                    436 ;	libs/i2c_lib.c: 39: I2C_CR2 -> START = 1; // Отправляем стартовый сигнал
      000198 72 10 52 11      [ 1]  437 	bset	0x5211, #0
                                    438 ;	libs/i2c_lib.c: 40: while(!(I2C_SR1 -> SB));// Ожидание отправки стартового сигнала
      00019C                        439 00101$:
      00019C 72 01 52 17 FB   [ 2]  440 	btjf	0x5217, #0, 00101$
                                    441 ;	libs/i2c_lib.c: 41: }
      0001A1 81               [ 4]  442 	ret
                                    443 ;	libs/i2c_lib.c: 43: uint8_t i2c_send_byte(unsigned char data){
                                    444 ;	-----------------------------------------
                                    445 ;	 function i2c_send_byte
                                    446 ;	-----------------------------------------
      0001A2                        447 _i2c_send_byte:
                                    448 ;	libs/i2c_lib.c: 44: uart_write("start send byte\n");
      0001A2 88               [ 1]  449 	push	a
      0001A3 AEr00r00         [ 2]  450 	ldw	x, #(___str_0+0)
      0001A6 CDr01r15         [ 4]  451 	call	_uart_write
      0001A9 84               [ 1]  452 	pop	a
                                    453 ;	libs/i2c_lib.c: 45: I2C_DR -> DR = data;
      0001AA C7 52 16         [ 1]  454 	ld	0x5216, a
                                    455 ;	libs/i2c_lib.c: 48: while (!(I2C_SR1 ->TXE) && (I2C_SR2 -> AF) && !(I2C_SR1 -> BTF));
      0001AD                        456 00103$:
      0001AD 72 0E 52 17 0A   [ 2]  457 	btjt	0x5217, #7, 00105$
      0001B2 72 0F 52 18 05   [ 2]  458 	btjf	0x5218, #7, 00105$
      0001B7 72 05 52 17 F1   [ 2]  459 	btjf	0x5217, #2, 00103$
      0001BC                        460 00105$:
                                    461 ;	libs/i2c_lib.c: 49: uart_write("DR byte\n");
      0001BC AEr00r11         [ 2]  462 	ldw	x, #(___str_1+0)
      0001BF CDr01r15         [ 4]  463 	call	_uart_write
                                    464 ;	libs/i2c_lib.c: 50: int result = I2C_SR2 -> AF;
      0001C2 C6 52 18         [ 1]  465 	ld	a, 0x5218
      0001C5 4E               [ 1]  466 	swap	a
      0001C6 44               [ 1]  467 	srl	a
      0001C7 44               [ 1]  468 	srl	a
      0001C8 44               [ 1]  469 	srl	a
      0001C9 A4 01            [ 1]  470 	and	a, #0x01
                                    471 ;	libs/i2c_lib.c: 51: return result;
                                    472 ;	libs/i2c_lib.c: 52: }
      0001CB 81               [ 4]  473 	ret
                                    474 ;	libs/i2c_lib.c: 54: uint8_t i2c_read_byte(unsigned char *data){
                                    475 ;	-----------------------------------------
                                    476 ;	 function i2c_read_byte
                                    477 ;	-----------------------------------------
      0001CC                        478 _i2c_read_byte:
                                    479 ;	libs/i2c_lib.c: 55: while (!(I2C_SR1 -> RXNE));
      0001CC                        480 00101$:
      0001CC 72 0D 52 17 FB   [ 2]  481 	btjf	0x5217, #6, 00101$
                                    482 ;	libs/i2c_lib.c: 57: return 0;
      0001D1 4F               [ 1]  483 	clr	a
                                    484 ;	libs/i2c_lib.c: 59: }
      0001D2 81               [ 4]  485 	ret
                                    486 ;	libs/i2c_lib.c: 61: void i2c_stop(void) {
                                    487 ;	-----------------------------------------
                                    488 ;	 function i2c_stop
                                    489 ;	-----------------------------------------
      0001D3                        490 _i2c_stop:
                                    491 ;	libs/i2c_lib.c: 62: I2C_CR2 -> STOP = 1;// Отправка стопового сигнала
      0001D3 72 12 52 11      [ 1]  492 	bset	0x5211, #1
                                    493 ;	libs/i2c_lib.c: 63: }
      0001D7 81               [ 4]  494 	ret
                                    495 ;	libs/i2c_lib.c: 66: uint8_t i2c_send_address(uint8_t address,uint8_t rw_type) 
                                    496 ;	-----------------------------------------
                                    497 ;	 function i2c_send_address
                                    498 ;	-----------------------------------------
      0001D8                        499 _i2c_send_address:
      0001D8 88               [ 1]  500 	push	a
                                    501 ;	libs/i2c_lib.c: 68: i2c_start();
      0001D9 88               [ 1]  502 	push	a
      0001DA CDr01r98         [ 4]  503 	call	_i2c_start
      0001DD 84               [ 1]  504 	pop	a
                                    505 ;	libs/i2c_lib.c: 72: address = address << 1;
      0001DE 48               [ 1]  506 	sll	a
                                    507 ;	libs/i2c_lib.c: 69: switch(rw_type)
      0001DF 88               [ 1]  508 	push	a
      0001E0 7B 05            [ 1]  509 	ld	a, (0x05, sp)
      0001E2 4A               [ 1]  510 	dec	a
      0001E3 84               [ 1]  511 	pop	a
      0001E4 26 02            [ 1]  512 	jrne	00102$
                                    513 ;	libs/i2c_lib.c: 72: address = address << 1;
                                    514 ;	libs/i2c_lib.c: 73: address |= 0x01; // Отправка адреса устройства с битом на чтение
      0001E6 AA 01            [ 1]  515 	or	a, #0x01
                                    516 ;	libs/i2c_lib.c: 74: break;
                                    517 ;	libs/i2c_lib.c: 75: default:
                                    518 ;	libs/i2c_lib.c: 76: address = address << 1; // Отправка адреса устройства с битом на запись
                                    519 ;	libs/i2c_lib.c: 78: }
      0001E8                        520 00102$:
                                    521 ;	libs/i2c_lib.c: 79: I2C_DR -> DR = address;
      0001E8 C7 52 16         [ 1]  522 	ld	0x5216, a
                                    523 ;	libs/i2c_lib.c: 80: int result = I2C_SR1 -> ADDR;//Отправка адреса
      0001EB C6 52 17         [ 1]  524 	ld	a, 0x5217
      0001EE 44               [ 1]  525 	srl	a
      0001EF A4 01            [ 1]  526 	and	a, #0x01
      0001F1 6B 01            [ 1]  527 	ld	(0x01, sp), a
                                    528 ;	libs/i2c_lib.c: 83: uart_write("WHILE start\n");
      0001F3 AEr00r1A         [ 2]  529 	ldw	x, #(___str_2+0)
      0001F6 CDr01r15         [ 4]  530 	call	_uart_write
                                    531 ;	libs/i2c_lib.c: 84: while (!(I2C_SR1 -> ADDR) && (I2C_SR2 -> AF));
      0001F9                        532 00105$:
      0001F9 72 02 52 17 05   [ 2]  533 	btjt	0x5217, #1, 00107$
      0001FE 72 0E 52 18 F6   [ 2]  534 	btjt	0x5218, #7, 00105$
      000203                        535 00107$:
                                    536 ;	libs/i2c_lib.c: 85: uart_write("WHILE passed\n");  
      000203 AEr00r27         [ 2]  537 	ldw	x, #(___str_3+0)
      000206 CDr01r15         [ 4]  538 	call	_uart_write
                                    539 ;	libs/i2c_lib.c: 91: return result;
      000209 7B 01            [ 1]  540 	ld	a, (0x01, sp)
                                    541 ;	libs/i2c_lib.c: 92: }
      00020B 5B 01            [ 2]  542 	addw	sp, #1
      00020D 85               [ 2]  543 	popw	x
      00020E 5B 01            [ 2]  544 	addw	sp, #1
      000210 FC               [ 2]  545 	jp	(x)
                                    546 ;	libs/i2c_lib.c: 94: void i2c_write(uint8_t dev_addr,uint8_t size,uint8_t *data)
                                    547 ;	-----------------------------------------
                                    548 ;	 function i2c_write
                                    549 ;	-----------------------------------------
      000211                        550 _i2c_write:
      000211 52 04            [ 2]  551 	sub	sp, #4
                                    552 ;	libs/i2c_lib.c: 96: if(i2c_send_address(dev_addr, 0))//Проверка на АСК бит
      000213 4B 00            [ 1]  553 	push	#0x00
      000215 CDr01rD8         [ 4]  554 	call	_i2c_send_address
      000218 4D               [ 1]  555 	tnz	a
      000219 27 3C            [ 1]  556 	jreq	00105$
                                    557 ;	libs/i2c_lib.c: 98: uart_write("PIVO\n");
      00021B AEr00r35         [ 2]  558 	ldw	x, #(___str_4+0)
      00021E CDr01r15         [ 4]  559 	call	_uart_write
                                    560 ;	libs/i2c_lib.c: 99: for(int i = 0;i < size;i++)
      000221 5F               [ 1]  561 	clrw	x
      000222 1F 03            [ 2]  562 	ldw	(0x03, sp), x
      000224                        563 00107$:
      000224 7B 07            [ 1]  564 	ld	a, (0x07, sp)
      000226 6B 02            [ 1]  565 	ld	(0x02, sp), a
      000228 0F 01            [ 1]  566 	clr	(0x01, sp)
      00022A 1E 03            [ 2]  567 	ldw	x, (0x03, sp)
      00022C 13 01            [ 2]  568 	cpw	x, (0x01, sp)
      00022E 2E 27            [ 1]  569 	jrsge	00105$
                                    570 ;	libs/i2c_lib.c: 101: uart_write("for\n");
      000230 AEr00r3B         [ 2]  571 	ldw	x, #(___str_5+0)
      000233 CDr01r15         [ 4]  572 	call	_uart_write
                                    573 ;	libs/i2c_lib.c: 102: if(i2c_send_byte(data[i]))//Проверка на АСК бит
      000236 1E 08            [ 2]  574 	ldw	x, (0x08, sp)
      000238 72 FB 03         [ 2]  575 	addw	x, (0x03, sp)
      00023B F6               [ 1]  576 	ld	a, (x)
      00023C CDr01rA2         [ 4]  577 	call	_i2c_send_byte
      00023F 4D               [ 1]  578 	tnz	a
      000240 27 08            [ 1]  579 	jreq	00102$
                                    580 ;	libs/i2c_lib.c: 104: uart_write("error send byte\n");
      000242 AEr00r40         [ 2]  581 	ldw	x, #(___str_6+0)
      000245 CDr01r15         [ 4]  582 	call	_uart_write
                                    583 ;	libs/i2c_lib.c: 105: break;
      000248 20 0D            [ 2]  584 	jra	00105$
      00024A                        585 00102$:
                                    586 ;	libs/i2c_lib.c: 109: uart_write("if passed\n");    
      00024A AEr00r51         [ 2]  587 	ldw	x, #(___str_7+0)
      00024D CDr01r15         [ 4]  588 	call	_uart_write
                                    589 ;	libs/i2c_lib.c: 99: for(int i = 0;i < size;i++)
      000250 1E 03            [ 2]  590 	ldw	x, (0x03, sp)
      000252 5C               [ 1]  591 	incw	x
      000253 1F 03            [ 2]  592 	ldw	(0x03, sp), x
      000255 20 CD            [ 2]  593 	jra	00107$
      000257                        594 00105$:
                                    595 ;	libs/i2c_lib.c: 112: i2c_stop();
      000257 1E 05            [ 2]  596 	ldw	x, (5, sp)
      000259 1F 08            [ 2]  597 	ldw	(8, sp), x
      00025B 5B 07            [ 2]  598 	addw	sp, #7
                                    599 ;	libs/i2c_lib.c: 113: }
      00025D CCr01rD3         [ 2]  600 	jp	_i2c_stop
                                    601 ;	libs/i2c_lib.c: 115: void i2c_read(uint8_t dev_addr, uint8_t size,uint8_t *data){
                                    602 ;	-----------------------------------------
                                    603 ;	 function i2c_read
                                    604 ;	-----------------------------------------
      000260                        605 _i2c_read:
      000260 52 02            [ 2]  606 	sub	sp, #2
                                    607 ;	libs/i2c_lib.c: 116: I2C_CR2 -> ACK = 1;
      000262 AE 52 11         [ 2]  608 	ldw	x, #0x5211
      000265 88               [ 1]  609 	push	a
      000266 F6               [ 1]  610 	ld	a, (x)
      000267 AA 04            [ 1]  611 	or	a, #0x04
      000269 F7               [ 1]  612 	ld	(x), a
      00026A 84               [ 1]  613 	pop	a
                                    614 ;	libs/i2c_lib.c: 117: if(i2c_send_address(dev_addr,1))
      00026B 4B 01            [ 1]  615 	push	#0x01
      00026D CDr01rD8         [ 4]  616 	call	_i2c_send_address
      000270 4D               [ 1]  617 	tnz	a
      000271 27 1F            [ 1]  618 	jreq	00103$
                                    619 ;	libs/i2c_lib.c: 118: for(int i = 0;i < size;i++)
      000273 5F               [ 1]  620 	clrw	x
      000274                        621 00105$:
      000274 7B 05            [ 1]  622 	ld	a, (0x05, sp)
      000276 6B 02            [ 1]  623 	ld	(0x02, sp), a
      000278 0F 01            [ 1]  624 	clr	(0x01, sp)
      00027A 13 01            [ 2]  625 	cpw	x, (0x01, sp)
      00027C 2E 14            [ 1]  626 	jrsge	00103$
                                    627 ;	libs/i2c_lib.c: 120: i2c_read_byte((unsigned char *)data[i]);
      00027E 90 93            [ 1]  628 	ldw	y, x
      000280 72 F9 06         [ 2]  629 	addw	y, (0x06, sp)
      000283 90 F6            [ 1]  630 	ld	a, (y)
      000285 90 5F            [ 1]  631 	clrw	y
      000287 90 97            [ 1]  632 	ld	yl, a
      000289 89               [ 2]  633 	pushw	x
      00028A 93               [ 1]  634 	ldw	x, y
      00028B CDr01rCC         [ 4]  635 	call	_i2c_read_byte
      00028E 85               [ 2]  636 	popw	x
                                    637 ;	libs/i2c_lib.c: 118: for(int i = 0;i < size;i++)
      00028F 5C               [ 1]  638 	incw	x
      000290 20 E2            [ 2]  639 	jra	00105$
      000292                        640 00103$:
                                    641 ;	libs/i2c_lib.c: 122: I2C_CR2 -> ACK = 0;
      000292 C6 52 11         [ 1]  642 	ld	a, 0x5211
      000295 A4 FB            [ 1]  643 	and	a, #0xfb
      000297 C7 52 11         [ 1]  644 	ld	0x5211, a
                                    645 ;	libs/i2c_lib.c: 123: }
      00029A 1E 03            [ 2]  646 	ldw	x, (3, sp)
      00029C 5B 07            [ 2]  647 	addw	sp, #7
      00029E FC               [ 2]  648 	jp	(x)
                                    649 ;	libs/i2c_lib.c: 124: uint8_t i2c_scan(void) 
                                    650 ;	-----------------------------------------
                                    651 ;	 function i2c_scan
                                    652 ;	-----------------------------------------
      00029F                        653 _i2c_scan:
      00029F 52 02            [ 2]  654 	sub	sp, #2
                                    655 ;	libs/i2c_lib.c: 126: for (uint8_t addr = 1; addr < 127; addr++)
      0002A1 A6 01            [ 1]  656 	ld	a, #0x01
      0002A3 6B 01            [ 1]  657 	ld	(0x01, sp), a
      0002A5 6B 02            [ 1]  658 	ld	(0x02, sp), a
      0002A7                        659 00105$:
      0002A7 7B 02            [ 1]  660 	ld	a, (0x02, sp)
      0002A9 A1 7F            [ 1]  661 	cp	a, #0x7f
      0002AB 24 23            [ 1]  662 	jrnc	00103$
                                    663 ;	libs/i2c_lib.c: 128: if(i2c_send_address(addr, 0))
      0002AD 4B 00            [ 1]  664 	push	#0x00
      0002AF 7B 03            [ 1]  665 	ld	a, (0x03, sp)
      0002B1 CDr01rD8         [ 4]  666 	call	_i2c_send_address
      0002B4 4D               [ 1]  667 	tnz	a
      0002B5 27 07            [ 1]  668 	jreq	00102$
                                    669 ;	libs/i2c_lib.c: 130: i2c_stop();
      0002B7 CDr01rD3         [ 4]  670 	call	_i2c_stop
                                    671 ;	libs/i2c_lib.c: 131: return addr;
      0002BA 7B 01            [ 1]  672 	ld	a, (0x01, sp)
      0002BC 20 16            [ 2]  673 	jra	00107$
      0002BE                        674 00102$:
                                    675 ;	libs/i2c_lib.c: 133: I2C_SR2 -> AF = 0;
      0002BE 72 1F 52 18      [ 1]  676 	bres	0x5218, #7
                                    677 ;	libs/i2c_lib.c: 134: uart_write("error addr\n"); //Очистка флага ошибки
      0002C2 AEr00r5C         [ 2]  678 	ldw	x, #(___str_8+0)
      0002C5 CDr01r15         [ 4]  679 	call	_uart_write
                                    680 ;	libs/i2c_lib.c: 126: for (uint8_t addr = 1; addr < 127; addr++)
      0002C8 0C 02            [ 1]  681 	inc	(0x02, sp)
      0002CA 7B 02            [ 1]  682 	ld	a, (0x02, sp)
      0002CC 6B 01            [ 1]  683 	ld	(0x01, sp), a
      0002CE 20 D7            [ 2]  684 	jra	00105$
      0002D0                        685 00103$:
                                    686 ;	libs/i2c_lib.c: 136: i2c_stop();
      0002D0 CDr01rD3         [ 4]  687 	call	_i2c_stop
                                    688 ;	libs/i2c_lib.c: 137: return 0;
      0002D3 4F               [ 1]  689 	clr	a
      0002D4                        690 00107$:
                                    691 ;	libs/i2c_lib.c: 138: }
      0002D4 5B 02            [ 2]  692 	addw	sp, #2
      0002D6 81               [ 4]  693 	ret
                                    694 ;	main.c: 3: int main(void)
                                    695 ;	-----------------------------------------
                                    696 ;	 function main
                                    697 ;	-----------------------------------------
      0002D7                        698 _main:
      0002D7 88               [ 1]  699 	push	a
                                    700 ;	main.c: 6: CLK_CKDIVR = 0;
      0002D8 35 00 50 C6      [ 1]  701 	mov	0x50c6+0, #0x00
                                    702 ;	main.c: 7: uart_init(9600,0);
      0002DC 4F               [ 1]  703 	clr	a
      0002DD AE 25 80         [ 2]  704 	ldw	x, #0x2580
      0002E0 CDr00r00         [ 4]  705 	call	_uart_init
                                    706 ;	main.c: 8: i2c_init();
      0002E3 CDr01r6D         [ 4]  707 	call	_i2c_init
                                    708 ;	main.c: 9: i2c_scan();
      0002E6 CDr02r9F         [ 4]  709 	call	_i2c_scan
                                    710 ;	main.c: 11: buf[0] = 0xA4;
      0002E9 A6 A4            [ 1]  711 	ld	a, #0xa4
      0002EB 6B 01            [ 1]  712 	ld	(0x01, sp), a
                                    713 ;	main.c: 12: i2c_write(I2C_DISPLAY_ADDR,1,buf);
      0002ED 96               [ 1]  714 	ldw	x, sp
      0002EE 5C               [ 1]  715 	incw	x
      0002EF 89               [ 2]  716 	pushw	x
      0002F0 4B 01            [ 1]  717 	push	#0x01
      0002F2 A6 3C            [ 1]  718 	ld	a, #0x3c
      0002F4 CDr02r11         [ 4]  719 	call	_i2c_write
                                    720 ;	main.c: 13: for(int i = 0;i < 256;i++)
      0002F7 5F               [ 1]  721 	clrw	x
      0002F8                        722 00103$:
      0002F8 A3 01 00         [ 2]  723 	cpw	x, #0x0100
      0002FB 2E 14            [ 1]  724 	jrsge	00101$
                                    725 ;	main.c: 15: i2c_write(I2C_DISPLAY_ADDR,1,buf);
      0002FD 89               [ 2]  726 	pushw	x
      0002FE 90 96            [ 1]  727 	ldw	y, sp
      000300 72 A9 00 03      [ 2]  728 	addw	y, #3
      000304 90 89            [ 2]  729 	pushw	y
      000306 4B 01            [ 1]  730 	push	#0x01
      000308 A6 3C            [ 1]  731 	ld	a, #0x3c
      00030A CDr02r11         [ 4]  732 	call	_i2c_write
      00030D 85               [ 2]  733 	popw	x
                                    734 ;	main.c: 13: for(int i = 0;i < 256;i++)
      00030E 5C               [ 1]  735 	incw	x
      00030F 20 E7            [ 2]  736 	jra	00103$
      000311                        737 00101$:
                                    738 ;	main.c: 17: return 0;
      000311 5F               [ 1]  739 	clrw	x
                                    740 ;	main.c: 18: }
      000312 84               [ 1]  741 	pop	a
      000313 81               [ 4]  742 	ret
                                    743 	.area CODE
                                    744 	.area CONST
                                    745 	.area CONST
      000000                        746 ___str_0:
      000000 73 74 61 72 74 20 73   747 	.ascii "start send byte"
             65 6E 64 20 62 79 74
             65
      00000F 0A                     748 	.db 0x0a
      000010 00                     749 	.db 0x00
                                    750 	.area CODE
                                    751 	.area CONST
      000011                        752 ___str_1:
      000011 44 52 20 62 79 74 65   753 	.ascii "DR byte"
      000018 0A                     754 	.db 0x0a
      000019 00                     755 	.db 0x00
                                    756 	.area CODE
                                    757 	.area CONST
      00001A                        758 ___str_2:
      00001A 57 48 49 4C 45 20 73   759 	.ascii "WHILE start"
             74 61 72 74
      000025 0A                     760 	.db 0x0a
      000026 00                     761 	.db 0x00
                                    762 	.area CODE
                                    763 	.area CONST
      000027                        764 ___str_3:
      000027 57 48 49 4C 45 20 70   765 	.ascii "WHILE passed"
             61 73 73 65 64
      000033 0A                     766 	.db 0x0a
      000034 00                     767 	.db 0x00
                                    768 	.area CODE
                                    769 	.area CONST
      000035                        770 ___str_4:
      000035 50 49 56 4F            771 	.ascii "PIVO"
      000039 0A                     772 	.db 0x0a
      00003A 00                     773 	.db 0x00
                                    774 	.area CODE
                                    775 	.area CONST
      00003B                        776 ___str_5:
      00003B 66 6F 72               777 	.ascii "for"
      00003E 0A                     778 	.db 0x0a
      00003F 00                     779 	.db 0x00
                                    780 	.area CODE
                                    781 	.area CONST
      000040                        782 ___str_6:
      000040 65 72 72 6F 72 20 73   783 	.ascii "error send byte"
             65 6E 64 20 62 79 74
             65
      00004F 0A                     784 	.db 0x0a
      000050 00                     785 	.db 0x00
                                    786 	.area CODE
                                    787 	.area CONST
      000051                        788 ___str_7:
      000051 69 66 20 70 61 73 73   789 	.ascii "if passed"
             65 64
      00005A 0A                     790 	.db 0x0a
      00005B 00                     791 	.db 0x00
                                    792 	.area CODE
                                    793 	.area CONST
      00005C                        794 ___str_8:
      00005C 65 72 72 6F 72 20 61   795 	.ascii "error addr"
             64 64 72
      000066 0A                     796 	.db 0x0a
      000067 00                     797 	.db 0x00
                                    798 	.area CODE
                                    799 	.area INITIALIZER
                                    800 	.area CABS (ABS)
