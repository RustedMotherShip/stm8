                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.4.0 #14620 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _setup
                                     13 	.globl _i2c_scan
                                     14 	.globl _i2c_write
                                     15 	.globl _i2c_send_byte
                                     16 	.globl _i2c_read
                                     17 	.globl _i2c_read_byte
                                     18 	.globl _i2c_send_address
                                     19 	.globl _i2c_stop
                                     20 	.globl _i2c_start
                                     21 	.globl _i2c_init
                                     22 	.globl _uart_read
                                     23 	.globl _uart_write_byte
                                     24 	.globl _uart_read_byte
                                     25 	.globl _uart_init
                                     26 	.globl _uart_reciever_irq
                                     27 	.globl _uart_transmission_irq
                                     28 	.globl _I2C_IRQ
                                     29 	.globl _buf_size
                                     30 	.globl _buf_pos
                                     31 	.globl _rx_buf_pointer
                                     32 	.globl _tx_buf_pointer
                                     33 	.globl _uart_write
                                     34 ;--------------------------------------------------------
                                     35 ; ram data
                                     36 ;--------------------------------------------------------
                                     37 	.area DATA
      000000                         38 _tx_buf_pointer::
      000000                         39 	.ds 2
      000002                         40 _rx_buf_pointer::
      000002                         41 	.ds 2
      000004                         42 _buf_pos::
      000004                         43 	.ds 1
      000005                         44 _buf_size::
      000005                         45 	.ds 1
                                     46 ;--------------------------------------------------------
                                     47 ; ram data
                                     48 ;--------------------------------------------------------
                                     49 	.area INITIALIZED
      000000                         50 _I2C_IRQ::
      000000                         51 	.ds 1
                                     52 ;--------------------------------------------------------
                                     53 ; Stack segment in internal ram
                                     54 ;--------------------------------------------------------
                                     55 	.area SSEG
      000000                         56 __start__stack:
      000000                         57 	.ds	1
                                     58 
                                     59 ;--------------------------------------------------------
                                     60 ; absolute external ram data
                                     61 ;--------------------------------------------------------
                                     62 	.area DABS (ABS)
                                     63 
                                     64 ; default segment ordering for linker
                                     65 	.area HOME
                                     66 	.area GSINIT
                                     67 	.area GSFINAL
                                     68 	.area CONST
                                     69 	.area INITIALIZER
                                     70 	.area CODE
                                     71 
                                     72 ;--------------------------------------------------------
                                     73 ; interrupt vector
                                     74 ;--------------------------------------------------------
                                     75 	.area HOME
      000000                         76 __interrupt_vect:
      000000 82v00u00u00             77 	int s_GSINIT ; reset
      000004 82 00 00 00             78 	int 0x000000 ; trap
      000008 82 00 00 00             79 	int 0x000000 ; int0
      00000C 82 00 00 00             80 	int 0x000000 ; int1
      000010 82 00 00 00             81 	int 0x000000 ; int2
      000014 82 00 00 00             82 	int 0x000000 ; int3
      000018 82 00 00 00             83 	int 0x000000 ; int4
      00001C 82 00 00 00             84 	int 0x000000 ; int5
      000020 82 00 00 00             85 	int 0x000000 ; int6
      000024 82 00 00 00             86 	int 0x000000 ; int7
      000028 82 00 00 00             87 	int 0x000000 ; int8
      00002C 82 00 00 00             88 	int 0x000000 ; int9
      000030 82 00 00 00             89 	int 0x000000 ; int10
      000034 82 00 00 00             90 	int 0x000000 ; int11
      000038 82 00 00 00             91 	int 0x000000 ; int12
      00003C 82 00 00 00             92 	int 0x000000 ; int13
      000040 82 00 00 00             93 	int 0x000000 ; int14
      000044 82 00 00 00             94 	int 0x000000 ; int15
      000048 82 00 00 00             95 	int 0x000000 ; int16
      00004C 82v00u00u00             96 	int _uart_transmission_irq ; int17
      000050 82v00u00u3C             97 	int _uart_reciever_irq ; int18
                                     98 ;--------------------------------------------------------
                                     99 ; global & static initialisations
                                    100 ;--------------------------------------------------------
                                    101 	.area HOME
                                    102 	.area GSINIT
                                    103 	.area GSFINAL
                                    104 	.area GSINIT
      000000 CDr00r00         [ 4]  105 	call	___sdcc_external_startup
      000003 4D               [ 1]  106 	tnz	a
      000004 27 03            [ 1]  107 	jreq	__sdcc_init_data
      000006 CCr00r54         [ 2]  108 	jp	__sdcc_program_startup
      000009                        109 __sdcc_init_data:
                                    110 ; stm8_genXINIT() start
      000009 AEr00r00         [ 2]  111 	ldw x, #l_DATA
      00000C 27 07            [ 1]  112 	jreq	00002$
      00000E                        113 00001$:
      00000E 72 4FuFFuFF      [ 1]  114 	clr (s_DATA - 1, x)
      000012 5A               [ 2]  115 	decw x
      000013 26 F9            [ 1]  116 	jrne	00001$
      000015                        117 00002$:
      000015 AEr00r00         [ 2]  118 	ldw	x, #l_INITIALIZER
      000018 27 09            [ 1]  119 	jreq	00004$
      00001A                        120 00003$:
      00001A D6uFFuFF         [ 1]  121 	ld	a, (s_INITIALIZER - 1, x)
      00001D D7uFFuFF         [ 1]  122 	ld	(s_INITIALIZED - 1, x), a
      000020 5A               [ 2]  123 	decw	x
      000021 26 F7            [ 1]  124 	jrne	00003$
      000023                        125 00004$:
                                    126 ; stm8_genXINIT() end
                                    127 	.area GSFINAL
      000000 CCr00r54         [ 2]  128 	jp	__sdcc_program_startup
                                    129 ;--------------------------------------------------------
                                    130 ; Home
                                    131 ;--------------------------------------------------------
                                    132 	.area HOME
                                    133 	.area HOME
      000054                        134 __sdcc_program_startup:
      000054 CCr03r3C         [ 2]  135 	jp	_main
                                    136 ;	return from main will return to caller
                                    137 ;--------------------------------------------------------
                                    138 ; code
                                    139 ;--------------------------------------------------------
                                    140 	.area CODE
                                    141 ;	libs/uart_lib.c: 3: void uart_transmission_irq(void) __interrupt(UART1_T_vector)
                                    142 ;	-----------------------------------------
                                    143 ;	 function uart_transmission_irq
                                    144 ;	-----------------------------------------
      000000                        145 _uart_transmission_irq:
                                    146 ;	libs/uart_lib.c: 5: if(UART1_SR -> TXE) 
      000000 AE 52 30         [ 2]  147 	ldw	x, #0x5230
      000003 F6               [ 1]  148 	ld	a, (x)
      000004 4E               [ 1]  149 	swap	a
      000005 44               [ 1]  150 	srl	a
      000006 44               [ 1]  151 	srl	a
      000007 44               [ 1]  152 	srl	a
      000008 A5 01            [ 1]  153 	bcp	a, #0x01
      00000A 27 2F            [ 1]  154 	jreq	00107$
                                    155 ;	libs/uart_lib.c: 7: if(tx_buf_pointer[buf_pos] != '\0' && buf_size>buf_pos)
      00000C C6u00u01         [ 1]  156 	ld	a, _tx_buf_pointer+1
      00000F CBu00u04         [ 1]  157 	add	a, _buf_pos+0
      000012 97               [ 1]  158 	ld	xl, a
      000013 C6u00u00         [ 1]  159 	ld	a, _tx_buf_pointer+0
      000016 A9 00            [ 1]  160 	adc	a, #0x00
      000018 95               [ 1]  161 	ld	xh, a
      000019 F6               [ 1]  162 	ld	a, (x)
      00001A 27 1B            [ 1]  163 	jreq	00102$
      00001C C6u00u04         [ 1]  164 	ld	a, _buf_pos+0
      00001F C1u00u05         [ 1]  165 	cp	a, _buf_size+0
      000022 24 13            [ 1]  166 	jrnc	00102$
                                    167 ;	libs/uart_lib.c: 8: UART1_DR -> DR = tx_buf_pointer[buf_pos++];
      000024 C6u00u04         [ 1]  168 	ld	a, _buf_pos+0
      000027 72 5Cu00u04      [ 1]  169 	inc	_buf_pos+0
      00002B 5F               [ 1]  170 	clrw	x
      00002C 97               [ 1]  171 	ld	xl, a
      00002D 72 BBu00u00      [ 2]  172 	addw	x, _tx_buf_pointer+0
      000031 F6               [ 1]  173 	ld	a, (x)
      000032 C7 52 31         [ 1]  174 	ld	0x5231, a
      000035 20 04            [ 2]  175 	jra	00107$
      000037                        176 00102$:
                                    177 ;	libs/uart_lib.c: 10: UART1_CR2 -> TIEN = 0;
      000037 72 1F 52 35      [ 1]  178 	bres	0x5235, #7
      00003B                        179 00107$:
                                    180 ;	libs/uart_lib.c: 14: }
      00003B 80               [11]  181 	iret
                                    182 ;	libs/uart_lib.c: 15: void uart_reciever_irq(void) __interrupt(UART1_R_vector)
                                    183 ;	-----------------------------------------
                                    184 ;	 function uart_reciever_irq
                                    185 ;	-----------------------------------------
      00003C                        186 _uart_reciever_irq:
      00003C 88               [ 1]  187 	push	a
                                    188 ;	libs/uart_lib.c: 19: if(UART1_SR -> RXNE)
      00003D C6 52 30         [ 1]  189 	ld	a, 0x5230
      000040 4E               [ 1]  190 	swap	a
      000041 44               [ 1]  191 	srl	a
      000042 A5 01            [ 1]  192 	bcp	a, #0x01
      000044 27 27            [ 1]  193 	jreq	00107$
                                    194 ;	libs/uart_lib.c: 21: trash_reg = UART1_DR -> DR;
      000046 C6 52 31         [ 1]  195 	ld	a, 0x5231
                                    196 ;	libs/uart_lib.c: 22: if(trash_reg != '\n' && buf_size>buf_pos)
      000049 6B 01            [ 1]  197 	ld	(0x01, sp), a
      00004B A1 0A            [ 1]  198 	cp	a, #0x0a
      00004D 27 1A            [ 1]  199 	jreq	00102$
      00004F C6u00u04         [ 1]  200 	ld	a, _buf_pos+0
      000052 C1u00u05         [ 1]  201 	cp	a, _buf_size+0
      000055 24 12            [ 1]  202 	jrnc	00102$
                                    203 ;	libs/uart_lib.c: 23: rx_buf_pointer[buf_pos++] = trash_reg;
      000057 C6u00u04         [ 1]  204 	ld	a, _buf_pos+0
      00005A 72 5Cu00u04      [ 1]  205 	inc	_buf_pos+0
      00005E 5F               [ 1]  206 	clrw	x
      00005F 97               [ 1]  207 	ld	xl, a
      000060 72 BBu00u02      [ 2]  208 	addw	x, _rx_buf_pointer+0
      000064 7B 01            [ 1]  209 	ld	a, (0x01, sp)
      000066 F7               [ 1]  210 	ld	(x), a
      000067 20 04            [ 2]  211 	jra	00107$
      000069                        212 00102$:
                                    213 ;	libs/uart_lib.c: 25: UART1_CR2 -> RIEN = 0;
      000069 72 1B 52 35      [ 1]  214 	bres	0x5235, #5
      00006D                        215 00107$:
                                    216 ;	libs/uart_lib.c: 29: }
      00006D 84               [ 1]  217 	pop	a
      00006E 80               [11]  218 	iret
                                    219 ;	libs/uart_lib.c: 30: void uart_init(unsigned int baudrate,uint8_t stopbit)
                                    220 ;	-----------------------------------------
                                    221 ;	 function uart_init
                                    222 ;	-----------------------------------------
      00006F                        223 _uart_init:
      00006F 52 02            [ 2]  224 	sub	sp, #2
      000071 1F 01            [ 2]  225 	ldw	(0x01, sp), x
                                    226 ;	libs/uart_lib.c: 34: UART1_CR2 -> TEN = 1; // Transmitter enable
      000073 AE 52 35         [ 2]  227 	ldw	x, #0x5235
      000076 88               [ 1]  228 	push	a
      000077 F6               [ 1]  229 	ld	a, (x)
      000078 AA 08            [ 1]  230 	or	a, #0x08
      00007A F7               [ 1]  231 	ld	(x), a
      00007B 84               [ 1]  232 	pop	a
                                    233 ;	libs/uart_lib.c: 35: UART1_CR2 -> REN = 1; // Receiver enable
      00007C AE 52 35         [ 2]  234 	ldw	x, #0x5235
      00007F 88               [ 1]  235 	push	a
      000080 F6               [ 1]  236 	ld	a, (x)
      000081 AA 04            [ 1]  237 	or	a, #0x04
      000083 F7               [ 1]  238 	ld	(x), a
      000084 84               [ 1]  239 	pop	a
                                    240 ;	libs/uart_lib.c: 36: switch(stopbit)
      000085 A1 02            [ 1]  241 	cp	a, #0x02
      000087 27 06            [ 1]  242 	jreq	00101$
      000089 A1 03            [ 1]  243 	cp	a, #0x03
      00008B 27 0E            [ 1]  244 	jreq	00102$
      00008D 20 16            [ 2]  245 	jra	00103$
                                    246 ;	libs/uart_lib.c: 38: case 2:
      00008F                        247 00101$:
                                    248 ;	libs/uart_lib.c: 39: UART1_CR3 -> STOP = 2;
      00008F C6 52 36         [ 1]  249 	ld	a, 0x5236
      000092 A4 CF            [ 1]  250 	and	a, #0xcf
      000094 AA 20            [ 1]  251 	or	a, #0x20
      000096 C7 52 36         [ 1]  252 	ld	0x5236, a
                                    253 ;	libs/uart_lib.c: 40: break;
      000099 20 12            [ 2]  254 	jra	00104$
                                    255 ;	libs/uart_lib.c: 41: case 3:
      00009B                        256 00102$:
                                    257 ;	libs/uart_lib.c: 42: UART1_CR3 -> STOP = 3;
      00009B C6 52 36         [ 1]  258 	ld	a, 0x5236
      00009E AA 30            [ 1]  259 	or	a, #0x30
      0000A0 C7 52 36         [ 1]  260 	ld	0x5236, a
                                    261 ;	libs/uart_lib.c: 43: break;
      0000A3 20 08            [ 2]  262 	jra	00104$
                                    263 ;	libs/uart_lib.c: 44: default:
      0000A5                        264 00103$:
                                    265 ;	libs/uart_lib.c: 45: UART1_CR3 -> STOP = 0;
      0000A5 C6 52 36         [ 1]  266 	ld	a, 0x5236
      0000A8 A4 CF            [ 1]  267 	and	a, #0xcf
      0000AA C7 52 36         [ 1]  268 	ld	0x5236, a
                                    269 ;	libs/uart_lib.c: 47: }
      0000AD                        270 00104$:
                                    271 ;	libs/uart_lib.c: 48: switch(baudrate)
      0000AD 1E 01            [ 2]  272 	ldw	x, (0x01, sp)
      0000AF A3 08 00         [ 2]  273 	cpw	x, #0x0800
      0000B2 26 03            [ 1]  274 	jrne	00186$
      0000B4 CCr01r40         [ 2]  275 	jp	00110$
      0000B7                        276 00186$:
      0000B7 1E 01            [ 2]  277 	ldw	x, (0x01, sp)
      0000B9 A3 09 60         [ 2]  278 	cpw	x, #0x0960
      0000BC 27 28            [ 1]  279 	jreq	00105$
      0000BE 1E 01            [ 2]  280 	ldw	x, (0x01, sp)
      0000C0 A3 10 00         [ 2]  281 	cpw	x, #0x1000
      0000C3 26 03            [ 1]  282 	jrne	00192$
      0000C5 CCr01r50         [ 2]  283 	jp	00111$
      0000C8                        284 00192$:
      0000C8 1E 01            [ 2]  285 	ldw	x, (0x01, sp)
      0000CA A3 4B 00         [ 2]  286 	cpw	x, #0x4b00
      0000CD 27 31            [ 1]  287 	jreq	00106$
      0000CF 1E 01            [ 2]  288 	ldw	x, (0x01, sp)
      0000D1 A3 84 00         [ 2]  289 	cpw	x, #0x8400
      0000D4 27 5A            [ 1]  290 	jreq	00109$
      0000D6 1E 01            [ 2]  291 	ldw	x, (0x01, sp)
      0000D8 A3 C2 00         [ 2]  292 	cpw	x, #0xc200
      0000DB 27 43            [ 1]  293 	jreq	00108$
      0000DD 1E 01            [ 2]  294 	ldw	x, (0x01, sp)
      0000DF A3 E1 00         [ 2]  295 	cpw	x, #0xe100
      0000E2 27 2C            [ 1]  296 	jreq	00107$
      0000E4 20 7A            [ 2]  297 	jra	00112$
                                    298 ;	libs/uart_lib.c: 50: case (unsigned int)2400:
      0000E6                        299 00105$:
                                    300 ;	libs/uart_lib.c: 51: UART1_BRR2 -> MSB = 0x01;
      0000E6 C6 52 33         [ 1]  301 	ld	a, 0x5233
      0000E9 A4 0F            [ 1]  302 	and	a, #0x0f
      0000EB AA 10            [ 1]  303 	or	a, #0x10
      0000ED C7 52 33         [ 1]  304 	ld	0x5233, a
                                    305 ;	libs/uart_lib.c: 52: UART1_BRR1 -> DIV = 0xA0;
      0000F0 35 A0 52 32      [ 1]  306 	mov	0x5232+0, #0xa0
                                    307 ;	libs/uart_lib.c: 53: UART1_BRR2 -> LSB = 0x0B; 
      0000F4 C6 52 33         [ 1]  308 	ld	a, 0x5233
      0000F7 A4 F0            [ 1]  309 	and	a, #0xf0
      0000F9 AA 0B            [ 1]  310 	or	a, #0x0b
      0000FB C7 52 33         [ 1]  311 	ld	0x5233, a
                                    312 ;	libs/uart_lib.c: 54: break;
      0000FE 20 6E            [ 2]  313 	jra	00114$
                                    314 ;	libs/uart_lib.c: 55: case (unsigned int)19200:
      000100                        315 00106$:
                                    316 ;	libs/uart_lib.c: 56: UART1_BRR1 -> DIV = 0x34;
      000100 35 34 52 32      [ 1]  317 	mov	0x5232+0, #0x34
                                    318 ;	libs/uart_lib.c: 57: UART1_BRR2 -> LSB = 0x01;
      000104 C6 52 33         [ 1]  319 	ld	a, 0x5233
      000107 A4 F0            [ 1]  320 	and	a, #0xf0
      000109 AA 01            [ 1]  321 	or	a, #0x01
      00010B C7 52 33         [ 1]  322 	ld	0x5233, a
                                    323 ;	libs/uart_lib.c: 58: break;
      00010E 20 5E            [ 2]  324 	jra	00114$
                                    325 ;	libs/uart_lib.c: 59: case (unsigned int)57600:
      000110                        326 00107$:
                                    327 ;	libs/uart_lib.c: 60: UART1_BRR1 -> DIV = 0x11;
      000110 35 11 52 32      [ 1]  328 	mov	0x5232+0, #0x11
                                    329 ;	libs/uart_lib.c: 61: UART1_BRR2 -> LSB = 0x06;
      000114 C6 52 33         [ 1]  330 	ld	a, 0x5233
      000117 A4 F0            [ 1]  331 	and	a, #0xf0
      000119 AA 06            [ 1]  332 	or	a, #0x06
      00011B C7 52 33         [ 1]  333 	ld	0x5233, a
                                    334 ;	libs/uart_lib.c: 62: break;
      00011E 20 4E            [ 2]  335 	jra	00114$
                                    336 ;	libs/uart_lib.c: 63: case (unsigned int)115200:
      000120                        337 00108$:
                                    338 ;	libs/uart_lib.c: 64: UART1_BRR1 -> DIV = 0x08;
      000120 35 08 52 32      [ 1]  339 	mov	0x5232+0, #0x08
                                    340 ;	libs/uart_lib.c: 65: UART1_BRR2 -> LSB = 0x0B;
      000124 C6 52 33         [ 1]  341 	ld	a, 0x5233
      000127 A4 F0            [ 1]  342 	and	a, #0xf0
      000129 AA 0B            [ 1]  343 	or	a, #0x0b
      00012B C7 52 33         [ 1]  344 	ld	0x5233, a
                                    345 ;	libs/uart_lib.c: 66: break;
      00012E 20 3E            [ 2]  346 	jra	00114$
                                    347 ;	libs/uart_lib.c: 67: case (unsigned int)230400:
      000130                        348 00109$:
                                    349 ;	libs/uart_lib.c: 68: UART1_BRR1 -> DIV = 0x04;
      000130 35 04 52 32      [ 1]  350 	mov	0x5232+0, #0x04
                                    351 ;	libs/uart_lib.c: 69: UART1_BRR2 -> LSB = 0x05;
      000134 C6 52 33         [ 1]  352 	ld	a, 0x5233
      000137 A4 F0            [ 1]  353 	and	a, #0xf0
      000139 AA 05            [ 1]  354 	or	a, #0x05
      00013B C7 52 33         [ 1]  355 	ld	0x5233, a
                                    356 ;	libs/uart_lib.c: 70: break;
      00013E 20 2E            [ 2]  357 	jra	00114$
                                    358 ;	libs/uart_lib.c: 71: case (unsigned int)460800:
      000140                        359 00110$:
                                    360 ;	libs/uart_lib.c: 72: UART1_BRR1 -> DIV = 0x02;
      000140 35 02 52 32      [ 1]  361 	mov	0x5232+0, #0x02
                                    362 ;	libs/uart_lib.c: 73: UART1_BRR2 -> LSB = 0x03;
      000144 C6 52 33         [ 1]  363 	ld	a, 0x5233
      000147 A4 F0            [ 1]  364 	and	a, #0xf0
      000149 AA 03            [ 1]  365 	or	a, #0x03
      00014B C7 52 33         [ 1]  366 	ld	0x5233, a
                                    367 ;	libs/uart_lib.c: 74: break;
      00014E 20 1E            [ 2]  368 	jra	00114$
                                    369 ;	libs/uart_lib.c: 75: case (unsigned int)921600:
      000150                        370 00111$:
                                    371 ;	libs/uart_lib.c: 76: UART1_BRR1 -> DIV = 0x01;
      000150 35 01 52 32      [ 1]  372 	mov	0x5232+0, #0x01
                                    373 ;	libs/uart_lib.c: 77: UART1_BRR2 -> LSB = 0x01;
      000154 C6 52 33         [ 1]  374 	ld	a, 0x5233
      000157 A4 F0            [ 1]  375 	and	a, #0xf0
      000159 AA 01            [ 1]  376 	or	a, #0x01
      00015B C7 52 33         [ 1]  377 	ld	0x5233, a
                                    378 ;	libs/uart_lib.c: 78: break;
      00015E 20 0E            [ 2]  379 	jra	00114$
                                    380 ;	libs/uart_lib.c: 79: default:
      000160                        381 00112$:
                                    382 ;	libs/uart_lib.c: 80: UART1_BRR1 -> DIV = 0x68;
      000160 35 68 52 32      [ 1]  383 	mov	0x5232+0, #0x68
                                    384 ;	libs/uart_lib.c: 81: UART1_BRR2 -> LSB = 0x03;
      000164 C6 52 33         [ 1]  385 	ld	a, 0x5233
      000167 A4 F0            [ 1]  386 	and	a, #0xf0
      000169 AA 03            [ 1]  387 	or	a, #0x03
      00016B C7 52 33         [ 1]  388 	ld	0x5233, a
                                    389 ;	libs/uart_lib.c: 83: }
      00016E                        390 00114$:
                                    391 ;	libs/uart_lib.c: 84: }
      00016E 5B 02            [ 2]  392 	addw	sp, #2
      000170 81               [ 4]  393 	ret
                                    394 ;	libs/uart_lib.c: 86: int uart_read_byte(uint8_t *data)
                                    395 ;	-----------------------------------------
                                    396 ;	 function uart_read_byte
                                    397 ;	-----------------------------------------
      000171                        398 _uart_read_byte:
                                    399 ;	libs/uart_lib.c: 88: while(!(UART1_SR -> RXNE));
      000171                        400 00101$:
      000171 72 0B 52 30 FB   [ 2]  401 	btjf	0x5230, #5, 00101$
                                    402 ;	libs/uart_lib.c: 90: return 1;
      000176 5F               [ 1]  403 	clrw	x
      000177 5C               [ 1]  404 	incw	x
                                    405 ;	libs/uart_lib.c: 91: }
      000178 81               [ 4]  406 	ret
                                    407 ;	libs/uart_lib.c: 93: int uart_write_byte(uint8_t data)
                                    408 ;	-----------------------------------------
                                    409 ;	 function uart_write_byte
                                    410 ;	-----------------------------------------
      000179                        411 _uart_write_byte:
                                    412 ;	libs/uart_lib.c: 95: UART1_DR -> DR = data;
      000179 C7 52 31         [ 1]  413 	ld	0x5231, a
                                    414 ;	libs/uart_lib.c: 96: while(!(UART1_SR -> TXE));
      00017C                        415 00101$:
      00017C 72 0F 52 30 FB   [ 2]  416 	btjf	0x5230, #7, 00101$
                                    417 ;	libs/uart_lib.c: 97: return 1;
      000181 5F               [ 1]  418 	clrw	x
      000182 5C               [ 1]  419 	incw	x
                                    420 ;	libs/uart_lib.c: 98: }
      000183 81               [ 4]  421 	ret
                                    422 ;	libs/uart_lib.c: 100: void uart_write(uint8_t *data_buf)
                                    423 ;	-----------------------------------------
                                    424 ;	 function uart_write
                                    425 ;	-----------------------------------------
      000184                        426 _uart_write:
      000184 52 02            [ 2]  427 	sub	sp, #2
                                    428 ;	libs/uart_lib.c: 102: tx_buf_pointer = data_buf;
      000186 1F 01            [ 2]  429 	ldw	(0x01, sp), x
      000188 CFu00u00         [ 2]  430 	ldw	_tx_buf_pointer+0, x
                                    431 ;	libs/uart_lib.c: 103: buf_pos = 0;
      00018B 72 5Fu00u04      [ 1]  432 	clr	_buf_pos+0
                                    433 ;	libs/uart_lib.c: 104: buf_size = 0;
      00018F 72 5Fu00u05      [ 1]  434 	clr	_buf_size+0
                                    435 ;	libs/uart_lib.c: 105: while (data_buf[buf_size++] != '\0');
      000193                        436 00101$:
      000193 C6u00u05         [ 1]  437 	ld	a, _buf_size+0
      000196 72 5Cu00u05      [ 1]  438 	inc	_buf_size+0
      00019A 5F               [ 1]  439 	clrw	x
      00019B 97               [ 1]  440 	ld	xl, a
      00019C 72 FB 01         [ 2]  441 	addw	x, (0x01, sp)
      00019F F6               [ 1]  442 	ld	a, (x)
      0001A0 26 F1            [ 1]  443 	jrne	00101$
                                    444 ;	libs/uart_lib.c: 106: UART1_CR2 -> TIEN = 1;
      0001A2 72 1E 52 35      [ 1]  445 	bset	0x5235, #7
                                    446 ;	libs/uart_lib.c: 107: while(UART1_CR2 -> TIEN);
      0001A6                        447 00104$:
      0001A6 72 0E 52 35 FB   [ 2]  448 	btjt	0x5235, #7, 00104$
                                    449 ;	libs/uart_lib.c: 108: }
      0001AB 5B 02            [ 2]  450 	addw	sp, #2
      0001AD 81               [ 4]  451 	ret
                                    452 ;	libs/uart_lib.c: 109: void uart_read(uint8_t *data_buf,int size)
                                    453 ;	-----------------------------------------
                                    454 ;	 function uart_read
                                    455 ;	-----------------------------------------
      0001AE                        456 _uart_read:
                                    457 ;	libs/uart_lib.c: 111: rx_buf_pointer = data_buf;
      0001AE CFu00u02         [ 2]  458 	ldw	_rx_buf_pointer+0, x
                                    459 ;	libs/uart_lib.c: 112: uart_write("rx_buf_pointer\n");
      0001B1 AEr00r00         [ 2]  460 	ldw	x, #(___str_0+0)
      0001B4 CDr01r84         [ 4]  461 	call	_uart_write
                                    462 ;	libs/uart_lib.c: 113: buf_pos = 0;
      0001B7 72 5Fu00u04      [ 1]  463 	clr	_buf_pos+0
                                    464 ;	libs/uart_lib.c: 114: uart_write("buf_pos\n");
      0001BB AEr00r10         [ 2]  465 	ldw	x, #(___str_1+0)
      0001BE CDr01r84         [ 4]  466 	call	_uart_write
                                    467 ;	libs/uart_lib.c: 115: buf_size = size;
      0001C1 7B 04            [ 1]  468 	ld	a, (0x04, sp)
      0001C3 C7u00u05         [ 1]  469 	ld	_buf_size+0, a
                                    470 ;	libs/uart_lib.c: 116: uart_write("buf_size\n");
      0001C6 AEr00r19         [ 2]  471 	ldw	x, #(___str_2+0)
      0001C9 CDr01r84         [ 4]  472 	call	_uart_write
                                    473 ;	libs/uart_lib.c: 117: UART1_CR2 -> RIEN = 1;
      0001CC 72 1A 52 35      [ 1]  474 	bset	0x5235, #5
                                    475 ;	libs/uart_lib.c: 118: uart_write("RIEN\n");
      0001D0 AEr00r23         [ 2]  476 	ldw	x, #(___str_3+0)
      0001D3 CDr01r84         [ 4]  477 	call	_uart_write
                                    478 ;	libs/uart_lib.c: 119: while(UART1_CR2 -> RIEN);
      0001D6                        479 00101$:
      0001D6 C6 52 35         [ 1]  480 	ld	a, 0x5235
      0001D9 4E               [ 1]  481 	swap	a
      0001DA 44               [ 1]  482 	srl	a
      0001DB A4 01            [ 1]  483 	and	a, #0x01
      0001DD 26 F7            [ 1]  484 	jrne	00101$
                                    485 ;	libs/uart_lib.c: 120: }
      0001DF 1E 01            [ 2]  486 	ldw	x, (1, sp)
      0001E1 5B 04            [ 2]  487 	addw	sp, #4
      0001E3 FC               [ 2]  488 	jp	(x)
                                    489 ;	libs/i2c_lib.c: 3: void i2c_init(void)
                                    490 ;	-----------------------------------------
                                    491 ;	 function i2c_init
                                    492 ;	-----------------------------------------
      0001E4                        493 _i2c_init:
                                    494 ;	libs/i2c_lib.c: 7: I2C_CR1 -> PE = 0;// PE=0, disable I2C before setup
      0001E4 72 11 52 10      [ 1]  495 	bres	0x5210, #0
                                    496 ;	libs/i2c_lib.c: 8: I2C_FREQR -> FREQ = 16;// peripheral frequence =16MHz
      0001E8 C6 52 12         [ 1]  497 	ld	a, 0x5212
      0001EB A4 C0            [ 1]  498 	and	a, #0xc0
      0001ED AA 10            [ 1]  499 	or	a, #0x10
      0001EF C7 52 12         [ 1]  500 	ld	0x5212, a
                                    501 ;	libs/i2c_lib.c: 9: I2C_CCRH -> CCR = 0;// =0
      0001F2 C6 52 1C         [ 1]  502 	ld	a, 0x521c
      0001F5 A4 F0            [ 1]  503 	and	a, #0xf0
      0001F7 C7 52 1C         [ 1]  504 	ld	0x521c, a
                                    505 ;	libs/i2c_lib.c: 10: I2C_CCRL -> CCR = 80;// 100kHz for I2C
      0001FA 35 50 52 1B      [ 1]  506 	mov	0x521b+0, #0x50
                                    507 ;	libs/i2c_lib.c: 11: I2C_CCRH -> FS = 0;// set standart mode(100кHz)
      0001FE 72 1F 52 1C      [ 1]  508 	bres	0x521c, #7
                                    509 ;	libs/i2c_lib.c: 12: I2C_OARH -> ADDMODE = 0;// 7-bit address mode
      000202 72 1F 52 14      [ 1]  510 	bres	0x5214, #7
                                    511 ;	libs/i2c_lib.c: 13: I2C_OARH -> ADDCONF = 1;// see reference manual
      000206 72 10 52 14      [ 1]  512 	bset	0x5214, #0
                                    513 ;	libs/i2c_lib.c: 14: I2C_CR1 -> PE = 1;// PE=1, enable I2C
      00020A 72 10 52 10      [ 1]  514 	bset	0x5210, #0
                                    515 ;	libs/i2c_lib.c: 15: }
      00020E 81               [ 4]  516 	ret
                                    517 ;	libs/i2c_lib.c: 17: void i2c_start(void)
                                    518 ;	-----------------------------------------
                                    519 ;	 function i2c_start
                                    520 ;	-----------------------------------------
      00020F                        521 _i2c_start:
                                    522 ;	libs/i2c_lib.c: 19: I2C_CR2 -> START = 1;// Отправляем стартовый сигнал
      00020F 72 10 52 11      [ 1]  523 	bset	0x5211, #0
                                    524 ;	libs/i2c_lib.c: 20: while(!I2C_SR1 -> SB);// Ожидание отправки стартового сигнала
      000213                        525 00101$:
      000213 72 01 52 17 FB   [ 2]  526 	btjf	0x5217, #0, 00101$
                                    527 ;	libs/i2c_lib.c: 21: }
      000218 81               [ 4]  528 	ret
                                    529 ;	libs/i2c_lib.c: 23: void i2c_stop(void)
                                    530 ;	-----------------------------------------
                                    531 ;	 function i2c_stop
                                    532 ;	-----------------------------------------
      000219                        533 _i2c_stop:
                                    534 ;	libs/i2c_lib.c: 25: I2C_CR2 -> STOP = 1;// Отправка стопового сигнала  
      000219 72 12 52 11      [ 1]  535 	bset	0x5211, #1
                                    536 ;	libs/i2c_lib.c: 26: }
      00021D 81               [ 4]  537 	ret
                                    538 ;	libs/i2c_lib.c: 28: uint8_t i2c_send_address(uint8_t address,uint8_t rw_type) 
                                    539 ;	-----------------------------------------
                                    540 ;	 function i2c_send_address
                                    541 ;	-----------------------------------------
      00021E                        542 _i2c_send_address:
                                    543 ;	libs/i2c_lib.c: 33: address = address << 1;
      00021E 48               [ 1]  544 	sll	a
                                    545 ;	libs/i2c_lib.c: 30: switch(rw_type)
      00021F 88               [ 1]  546 	push	a
      000220 7B 04            [ 1]  547 	ld	a, (0x04, sp)
      000222 4A               [ 1]  548 	dec	a
      000223 84               [ 1]  549 	pop	a
      000224 26 02            [ 1]  550 	jrne	00102$
                                    551 ;	libs/i2c_lib.c: 33: address = address << 1;
                                    552 ;	libs/i2c_lib.c: 34: address |= 0x01; // Отправка адреса устройства с битом на чтение
      000226 AA 01            [ 1]  553 	or	a, #0x01
                                    554 ;	libs/i2c_lib.c: 35: break;
                                    555 ;	libs/i2c_lib.c: 36: default:
                                    556 ;	libs/i2c_lib.c: 37: address = address << 1; // Отправка адреса устройства с битом на запись
                                    557 ;	libs/i2c_lib.c: 39: }
      000228                        558 00102$:
                                    559 ;	libs/i2c_lib.c: 40: i2c_start();
      000228 88               [ 1]  560 	push	a
      000229 CDr02r0F         [ 4]  561 	call	_i2c_start
      00022C 84               [ 1]  562 	pop	a
                                    563 ;	libs/i2c_lib.c: 41: I2C_DR -> DR = address;
      00022D C7 52 16         [ 1]  564 	ld	0x5216, a
                                    565 ;	libs/i2c_lib.c: 42: while(!I2C_SR1 -> ADDR)
      000230                        566 00106$:
      000230 AE 52 17         [ 2]  567 	ldw	x, #0x5217
      000233 F6               [ 1]  568 	ld	a, (x)
      000234 44               [ 1]  569 	srl	a
      000235 A4 01            [ 1]  570 	and	a, #0x01
      000237 26 08            [ 1]  571 	jrne	00108$
                                    572 ;	libs/i2c_lib.c: 43: if(I2C_SR2 -> AF)
      000239 72 05 52 18 F2   [ 2]  573 	btjf	0x5218, #2, 00106$
                                    574 ;	libs/i2c_lib.c: 44: return 0;
      00023E 4F               [ 1]  575 	clr	a
      00023F 20 08            [ 2]  576 	jra	00109$
      000241                        577 00108$:
                                    578 ;	libs/i2c_lib.c: 45: clr_sr1();
      000241 C6 52 17         [ 1]  579 	ld	a,0x5217
                                    580 ;	libs/i2c_lib.c: 46: clr_sr3();
      000244 C6 52 19         [ 1]  581 	ld	a,0x5219
                                    582 ;	libs/i2c_lib.c: 47: return 1;
      000247 A6 01            [ 1]  583 	ld	a, #0x01
      000249                        584 00109$:
                                    585 ;	libs/i2c_lib.c: 48: }
      000249 85               [ 2]  586 	popw	x
      00024A 5B 01            [ 2]  587 	addw	sp, #1
      00024C FC               [ 2]  588 	jp	(x)
                                    589 ;	libs/i2c_lib.c: 50: uint8_t i2c_read_byte(void){
                                    590 ;	-----------------------------------------
                                    591 ;	 function i2c_read_byte
                                    592 ;	-----------------------------------------
      00024D                        593 _i2c_read_byte:
                                    594 ;	libs/i2c_lib.c: 51: while(!I2C_SR1 -> RXNE);
      00024D                        595 00101$:
      00024D 72 0D 52 17 FB   [ 2]  596 	btjf	0x5217, #6, 00101$
                                    597 ;	libs/i2c_lib.c: 52: return I2C_DR -> DR;
      000252 C6 52 16         [ 1]  598 	ld	a, 0x5216
                                    599 ;	libs/i2c_lib.c: 53: }
      000255 81               [ 4]  600 	ret
                                    601 ;	libs/i2c_lib.c: 55: void i2c_read(uint8_t dev_addr, uint8_t size,uint8_t *data)
                                    602 ;	-----------------------------------------
                                    603 ;	 function i2c_read
                                    604 ;	-----------------------------------------
      000256                        605 _i2c_read:
      000256 52 04            [ 2]  606 	sub	sp, #4
                                    607 ;	libs/i2c_lib.c: 57: if(i2c_send_address(dev_addr, 1))//проверка на ACK
      000258 4B 01            [ 1]  608 	push	#0x01
      00025A CDr02r1E         [ 4]  609 	call	_i2c_send_address
      00025D 4D               [ 1]  610 	tnz	a
      00025E 27 41            [ 1]  611 	jreq	00103$
                                    612 ;	libs/i2c_lib.c: 59: I2C_CR2 -> ACK = 1;//включение ответа на посылки 
      000260 72 14 52 11      [ 1]  613 	bset	0x5211, #2
                                    614 ;	libs/i2c_lib.c: 60: for(int i = 0;i < size-1;i++) //цикл чтения данных с шины
      000264 5F               [ 1]  615 	clrw	x
      000265 1F 03            [ 2]  616 	ldw	(0x03, sp), x
      000267                        617 00105$:
      000267 5F               [ 1]  618 	clrw	x
      000268 7B 07            [ 1]  619 	ld	a, (0x07, sp)
      00026A 97               [ 1]  620 	ld	xl, a
      00026B 5A               [ 2]  621 	decw	x
      00026C 1F 01            [ 2]  622 	ldw	(0x01, sp), x
      00026E 1E 03            [ 2]  623 	ldw	x, (0x03, sp)
      000270 13 01            [ 2]  624 	cpw	x, (0x01, sp)
      000272 2E 12            [ 1]  625 	jrsge	00101$
                                    626 ;	libs/i2c_lib.c: 62: data[i] = i2c_read_byte();//функция записи байта в элемент массива
      000274 1E 08            [ 2]  627 	ldw	x, (0x08, sp)
      000276 72 FB 03         [ 2]  628 	addw	x, (0x03, sp)
      000279 89               [ 2]  629 	pushw	x
      00027A CDr02r4D         [ 4]  630 	call	_i2c_read_byte
      00027D 85               [ 2]  631 	popw	x
      00027E F7               [ 1]  632 	ld	(x), a
                                    633 ;	libs/i2c_lib.c: 60: for(int i = 0;i < size-1;i++) //цикл чтения данных с шины
      00027F 1E 03            [ 2]  634 	ldw	x, (0x03, sp)
      000281 5C               [ 1]  635 	incw	x
      000282 1F 03            [ 2]  636 	ldw	(0x03, sp), x
      000284 20 E1            [ 2]  637 	jra	00105$
      000286                        638 00101$:
                                    639 ;	libs/i2c_lib.c: 64: I2C_CR2 -> ACK = 0;//выключение ответа на посылки
      000286 72 15 52 11      [ 1]  640 	bres	0x5211, #2
                                    641 ;	libs/i2c_lib.c: 65: uart_write_byte(0x00);
      00028A 4F               [ 1]  642 	clr	a
      00028B CDr01r79         [ 4]  643 	call	_uart_write_byte
                                    644 ;	libs/i2c_lib.c: 66: data[size-1] = i2c_read_byte();
      00028E 1E 08            [ 2]  645 	ldw	x, (0x08, sp)
      000290 72 FB 01         [ 2]  646 	addw	x, (0x01, sp)
      000293 89               [ 2]  647 	pushw	x
      000294 CDr02r4D         [ 4]  648 	call	_i2c_read_byte
      000297 85               [ 2]  649 	popw	x
      000298 F7               [ 1]  650 	ld	(x), a
                                    651 ;	libs/i2c_lib.c: 67: uart_write_byte(0x01);
      000299 A6 01            [ 1]  652 	ld	a, #0x01
      00029B CDr01r79         [ 4]  653 	call	_uart_write_byte
                                    654 ;	libs/i2c_lib.c: 68: i2c_stop();
      00029E CDr02r19         [ 4]  655 	call	_i2c_stop
      0002A1                        656 00103$:
                                    657 ;	libs/i2c_lib.c: 70: uart_write_byte(0x02);
      0002A1 A6 02            [ 1]  658 	ld	a, #0x02
      0002A3 CDr01r79         [ 4]  659 	call	_uart_write_byte
                                    660 ;	libs/i2c_lib.c: 71: i2c_stop();
      0002A6 CDr02r19         [ 4]  661 	call	_i2c_stop
                                    662 ;	libs/i2c_lib.c: 72: i2c_stop();
      0002A9 CDr02r19         [ 4]  663 	call	_i2c_stop
                                    664 ;	libs/i2c_lib.c: 73: uart_write_byte(0x03); 
      0002AC A6 03            [ 1]  665 	ld	a, #0x03
      0002AE 1E 05            [ 2]  666 	ldw	x, (5, sp)
      0002B0 1F 08            [ 2]  667 	ldw	(8, sp), x
      0002B2 5B 07            [ 2]  668 	addw	sp, #7
                                    669 ;	libs/i2c_lib.c: 74: }
      0002B4 CCr01r79         [ 2]  670 	jp	_uart_write_byte
                                    671 ;	libs/i2c_lib.c: 76: uint8_t i2c_send_byte(uint8_t data)
                                    672 ;	-----------------------------------------
                                    673 ;	 function i2c_send_byte
                                    674 ;	-----------------------------------------
      0002B7                        675 _i2c_send_byte:
                                    676 ;	libs/i2c_lib.c: 78: I2C_DR -> DR = data; //Отправка данных
      0002B7 C7 52 16         [ 1]  677 	ld	0x5216, a
                                    678 ;	libs/i2c_lib.c: 79: while(!I2C_SR1 -> TXE)
      0002BA                        679 00103$:
      0002BA 72 0E 52 17 07   [ 2]  680 	btjt	0x5217, #7, 00105$
                                    681 ;	libs/i2c_lib.c: 80: if(I2C_SR2 -> AF)
      0002BF 72 05 52 18 F6   [ 2]  682 	btjf	0x5218, #2, 00103$
                                    683 ;	libs/i2c_lib.c: 81: return 0;
      0002C4 4F               [ 1]  684 	clr	a
      0002C5 81               [ 4]  685 	ret
      0002C6                        686 00105$:
                                    687 ;	libs/i2c_lib.c: 82: return 1;//флаг ответа
      0002C6 A6 01            [ 1]  688 	ld	a, #0x01
                                    689 ;	libs/i2c_lib.c: 83: }
      0002C8 81               [ 4]  690 	ret
                                    691 ;	libs/i2c_lib.c: 85: void i2c_write(uint8_t dev_addr,uint8_t size,uint8_t *data)
                                    692 ;	-----------------------------------------
                                    693 ;	 function i2c_write
                                    694 ;	-----------------------------------------
      0002C9                        695 _i2c_write:
      0002C9 52 02            [ 2]  696 	sub	sp, #2
                                    697 ;	libs/i2c_lib.c: 87: if(i2c_send_address(dev_addr, 0))//Проверка на АСК бит
      0002CB 4B 00            [ 1]  698 	push	#0x00
      0002CD CDr02r1E         [ 4]  699 	call	_i2c_send_address
      0002D0 4D               [ 1]  700 	tnz	a
      0002D1 27 1D            [ 1]  701 	jreq	00105$
                                    702 ;	libs/i2c_lib.c: 88: for(int i = 0;i < size;i++)
      0002D3 5F               [ 1]  703 	clrw	x
      0002D4                        704 00107$:
      0002D4 7B 05            [ 1]  705 	ld	a, (0x05, sp)
      0002D6 6B 02            [ 1]  706 	ld	(0x02, sp), a
      0002D8 0F 01            [ 1]  707 	clr	(0x01, sp)
      0002DA 13 01            [ 2]  708 	cpw	x, (0x01, sp)
      0002DC 2E 12            [ 1]  709 	jrsge	00105$
                                    710 ;	libs/i2c_lib.c: 90: if(i2c_send_byte(data[i]))//Проверка на АСК бит
      0002DE 90 93            [ 1]  711 	ldw	y, x
      0002E0 72 F9 06         [ 2]  712 	addw	y, (0x06, sp)
      0002E3 90 F6            [ 1]  713 	ld	a, (y)
      0002E5 89               [ 2]  714 	pushw	x
      0002E6 CDr02rB7         [ 4]  715 	call	_i2c_send_byte
      0002E9 85               [ 2]  716 	popw	x
      0002EA 4D               [ 1]  717 	tnz	a
      0002EB 26 03            [ 1]  718 	jrne	00105$
                                    719 ;	libs/i2c_lib.c: 88: for(int i = 0;i < size;i++)
      0002ED 5C               [ 1]  720 	incw	x
      0002EE 20 E4            [ 2]  721 	jra	00107$
      0002F0                        722 00105$:
                                    723 ;	libs/i2c_lib.c: 95: i2c_stop();
      0002F0 1E 03            [ 2]  724 	ldw	x, (3, sp)
      0002F2 1F 06            [ 2]  725 	ldw	(6, sp), x
      0002F4 5B 05            [ 2]  726 	addw	sp, #5
                                    727 ;	libs/i2c_lib.c: 96: }
      0002F6 CCr02r19         [ 2]  728 	jp	_i2c_stop
                                    729 ;	libs/i2c_lib.c: 98: uint8_t i2c_scan(void) 
                                    730 ;	-----------------------------------------
                                    731 ;	 function i2c_scan
                                    732 ;	-----------------------------------------
      0002F9                        733 _i2c_scan:
      0002F9 52 02            [ 2]  734 	sub	sp, #2
                                    735 ;	libs/i2c_lib.c: 100: for (uint8_t addr = 1; addr < 127; addr++)
      0002FB A6 01            [ 1]  736 	ld	a, #0x01
      0002FD 6B 01            [ 1]  737 	ld	(0x01, sp), a
      0002FF                        738 00105$:
      0002FF A1 7F            [ 1]  739 	cp	a, #0x7f
      000301 24 22            [ 1]  740 	jrnc	00103$
                                    741 ;	libs/i2c_lib.c: 102: if(i2c_send_address(addr, 0))//отправка адреса на проверку 
      000303 88               [ 1]  742 	push	a
      000304 4B 00            [ 1]  743 	push	#0x00
      000306 CDr02r1E         [ 4]  744 	call	_i2c_send_address
      000309 6B 03            [ 1]  745 	ld	(0x03, sp), a
      00030B 84               [ 1]  746 	pop	a
      00030C 0D 02            [ 1]  747 	tnz	(0x02, sp)
      00030E 27 07            [ 1]  748 	jreq	00102$
                                    749 ;	libs/i2c_lib.c: 104: i2c_stop();//адрес совпал 
      000310 CDr02r19         [ 4]  750 	call	_i2c_stop
                                    751 ;	libs/i2c_lib.c: 105: return addr;// выход из цикла
      000313 7B 01            [ 1]  752 	ld	a, (0x01, sp)
      000315 20 12            [ 2]  753 	jra	00107$
      000317                        754 00102$:
                                    755 ;	libs/i2c_lib.c: 107: I2C_SR2 -> AF = 0;//очистка флага ошибки
      000317 AE 52 18         [ 2]  756 	ldw	x, #0x5218
      00031A 88               [ 1]  757 	push	a
      00031B F6               [ 1]  758 	ld	a, (x)
      00031C A4 FB            [ 1]  759 	and	a, #0xfb
      00031E F7               [ 1]  760 	ld	(x), a
      00031F 84               [ 1]  761 	pop	a
                                    762 ;	libs/i2c_lib.c: 100: for (uint8_t addr = 1; addr < 127; addr++)
      000320 4C               [ 1]  763 	inc	a
      000321 6B 01            [ 1]  764 	ld	(0x01, sp), a
      000323 20 DA            [ 2]  765 	jra	00105$
      000325                        766 00103$:
                                    767 ;	libs/i2c_lib.c: 109: i2c_stop();//совпадений нет выход из функции
      000325 CDr02r19         [ 4]  768 	call	_i2c_stop
                                    769 ;	libs/i2c_lib.c: 110: return 0;
      000328 4F               [ 1]  770 	clr	a
      000329                        771 00107$:
                                    772 ;	libs/i2c_lib.c: 111: }
      000329 5B 02            [ 2]  773 	addw	sp, #2
      00032B 81               [ 4]  774 	ret
                                    775 ;	main.c: 2: void setup(void)
                                    776 ;	-----------------------------------------
                                    777 ;	 function setup
                                    778 ;	-----------------------------------------
      00032C                        779 _setup:
                                    780 ;	main.c: 5: CLK_CKDIVR = 0;
      00032C 35 00 50 C6      [ 1]  781 	mov	0x50c6+0, #0x00
                                    782 ;	main.c: 7: uart_init(9600,0);
      000330 4F               [ 1]  783 	clr	a
      000331 AE 25 80         [ 2]  784 	ldw	x, #0x2580
      000334 CDr00r6F         [ 4]  785 	call	_uart_init
                                    786 ;	main.c: 8: i2c_init();
      000337 CDr01rE4         [ 4]  787 	call	_i2c_init
                                    788 ;	main.c: 10: enableInterrupts();
      00033A 9A               [ 1]  789 	rim
                                    790 ;	main.c: 11: }
      00033B 81               [ 4]  791 	ret
                                    792 ;	main.c: 12: int main(void)
                                    793 ;	-----------------------------------------
                                    794 ;	 function main
                                    795 ;	-----------------------------------------
      00033C                        796 _main:
      00033C 52 84            [ 2]  797 	sub	sp, #132
                                    798 ;	main.c: 14: setup();
      00033E CDr03r2C         [ 4]  799 	call	_setup
                                    800 ;	main.c: 15: uint8_t buf[5] = {0};
      000341 96               [ 1]  801 	ldw	x, sp
      000342 5C               [ 1]  802 	incw	x
      000343 7F               [ 1]  803 	clr	(x)
      000344 0F 02            [ 1]  804 	clr	(0x02, sp)
      000346 0F 03            [ 1]  805 	clr	(0x03, sp)
      000348 0F 04            [ 1]  806 	clr	(0x04, sp)
      00034A 0F 05            [ 1]  807 	clr	(0x05, sp)
                                    808 ;	main.c: 16: uint8_t buf1[127] = {0};
      00034C 0F 06            [ 1]  809 	clr	(0x06, sp)
      00034E 0F 07            [ 1]  810 	clr	(0x07, sp)
      000350 0F 08            [ 1]  811 	clr	(0x08, sp)
      000352 0F 09            [ 1]  812 	clr	(0x09, sp)
      000354 0F 0A            [ 1]  813 	clr	(0x0a, sp)
      000356 0F 0B            [ 1]  814 	clr	(0x0b, sp)
      000358 0F 0C            [ 1]  815 	clr	(0x0c, sp)
      00035A 0F 0D            [ 1]  816 	clr	(0x0d, sp)
      00035C 0F 0E            [ 1]  817 	clr	(0x0e, sp)
      00035E 0F 0F            [ 1]  818 	clr	(0x0f, sp)
      000360 0F 10            [ 1]  819 	clr	(0x10, sp)
      000362 0F 11            [ 1]  820 	clr	(0x11, sp)
      000364 0F 12            [ 1]  821 	clr	(0x12, sp)
      000366 0F 13            [ 1]  822 	clr	(0x13, sp)
      000368 0F 14            [ 1]  823 	clr	(0x14, sp)
      00036A 0F 15            [ 1]  824 	clr	(0x15, sp)
      00036C 0F 16            [ 1]  825 	clr	(0x16, sp)
      00036E 0F 17            [ 1]  826 	clr	(0x17, sp)
      000370 0F 18            [ 1]  827 	clr	(0x18, sp)
      000372 0F 19            [ 1]  828 	clr	(0x19, sp)
      000374 0F 1A            [ 1]  829 	clr	(0x1a, sp)
      000376 0F 1B            [ 1]  830 	clr	(0x1b, sp)
      000378 0F 1C            [ 1]  831 	clr	(0x1c, sp)
      00037A 0F 1D            [ 1]  832 	clr	(0x1d, sp)
      00037C 0F 1E            [ 1]  833 	clr	(0x1e, sp)
      00037E 0F 1F            [ 1]  834 	clr	(0x1f, sp)
      000380 0F 20            [ 1]  835 	clr	(0x20, sp)
      000382 0F 21            [ 1]  836 	clr	(0x21, sp)
      000384 0F 22            [ 1]  837 	clr	(0x22, sp)
      000386 0F 23            [ 1]  838 	clr	(0x23, sp)
      000388 0F 24            [ 1]  839 	clr	(0x24, sp)
      00038A 0F 25            [ 1]  840 	clr	(0x25, sp)
      00038C 0F 26            [ 1]  841 	clr	(0x26, sp)
      00038E 0F 27            [ 1]  842 	clr	(0x27, sp)
      000390 0F 28            [ 1]  843 	clr	(0x28, sp)
      000392 0F 29            [ 1]  844 	clr	(0x29, sp)
      000394 0F 2A            [ 1]  845 	clr	(0x2a, sp)
      000396 0F 2B            [ 1]  846 	clr	(0x2b, sp)
      000398 0F 2C            [ 1]  847 	clr	(0x2c, sp)
      00039A 0F 2D            [ 1]  848 	clr	(0x2d, sp)
      00039C 0F 2E            [ 1]  849 	clr	(0x2e, sp)
      00039E 0F 2F            [ 1]  850 	clr	(0x2f, sp)
      0003A0 0F 30            [ 1]  851 	clr	(0x30, sp)
      0003A2 0F 31            [ 1]  852 	clr	(0x31, sp)
      0003A4 0F 32            [ 1]  853 	clr	(0x32, sp)
      0003A6 0F 33            [ 1]  854 	clr	(0x33, sp)
      0003A8 0F 34            [ 1]  855 	clr	(0x34, sp)
      0003AA 0F 35            [ 1]  856 	clr	(0x35, sp)
      0003AC 0F 36            [ 1]  857 	clr	(0x36, sp)
      0003AE 0F 37            [ 1]  858 	clr	(0x37, sp)
      0003B0 0F 38            [ 1]  859 	clr	(0x38, sp)
      0003B2 0F 39            [ 1]  860 	clr	(0x39, sp)
      0003B4 0F 3A            [ 1]  861 	clr	(0x3a, sp)
      0003B6 0F 3B            [ 1]  862 	clr	(0x3b, sp)
      0003B8 0F 3C            [ 1]  863 	clr	(0x3c, sp)
      0003BA 0F 3D            [ 1]  864 	clr	(0x3d, sp)
      0003BC 0F 3E            [ 1]  865 	clr	(0x3e, sp)
      0003BE 0F 3F            [ 1]  866 	clr	(0x3f, sp)
      0003C0 0F 40            [ 1]  867 	clr	(0x40, sp)
      0003C2 0F 41            [ 1]  868 	clr	(0x41, sp)
      0003C4 0F 42            [ 1]  869 	clr	(0x42, sp)
      0003C6 0F 43            [ 1]  870 	clr	(0x43, sp)
      0003C8 0F 44            [ 1]  871 	clr	(0x44, sp)
      0003CA 0F 45            [ 1]  872 	clr	(0x45, sp)
      0003CC 0F 46            [ 1]  873 	clr	(0x46, sp)
      0003CE 0F 47            [ 1]  874 	clr	(0x47, sp)
      0003D0 0F 48            [ 1]  875 	clr	(0x48, sp)
      0003D2 0F 49            [ 1]  876 	clr	(0x49, sp)
      0003D4 0F 4A            [ 1]  877 	clr	(0x4a, sp)
      0003D6 0F 4B            [ 1]  878 	clr	(0x4b, sp)
      0003D8 0F 4C            [ 1]  879 	clr	(0x4c, sp)
      0003DA 0F 4D            [ 1]  880 	clr	(0x4d, sp)
      0003DC 0F 4E            [ 1]  881 	clr	(0x4e, sp)
      0003DE 0F 4F            [ 1]  882 	clr	(0x4f, sp)
      0003E0 0F 50            [ 1]  883 	clr	(0x50, sp)
      0003E2 0F 51            [ 1]  884 	clr	(0x51, sp)
      0003E4 0F 52            [ 1]  885 	clr	(0x52, sp)
      0003E6 0F 53            [ 1]  886 	clr	(0x53, sp)
      0003E8 0F 54            [ 1]  887 	clr	(0x54, sp)
      0003EA 0F 55            [ 1]  888 	clr	(0x55, sp)
      0003EC 0F 56            [ 1]  889 	clr	(0x56, sp)
      0003EE 0F 57            [ 1]  890 	clr	(0x57, sp)
      0003F0 0F 58            [ 1]  891 	clr	(0x58, sp)
      0003F2 0F 59            [ 1]  892 	clr	(0x59, sp)
      0003F4 0F 5A            [ 1]  893 	clr	(0x5a, sp)
      0003F6 0F 5B            [ 1]  894 	clr	(0x5b, sp)
      0003F8 0F 5C            [ 1]  895 	clr	(0x5c, sp)
      0003FA 0F 5D            [ 1]  896 	clr	(0x5d, sp)
      0003FC 0F 5E            [ 1]  897 	clr	(0x5e, sp)
      0003FE 0F 5F            [ 1]  898 	clr	(0x5f, sp)
      000400 0F 60            [ 1]  899 	clr	(0x60, sp)
      000402 0F 61            [ 1]  900 	clr	(0x61, sp)
      000404 0F 62            [ 1]  901 	clr	(0x62, sp)
      000406 0F 63            [ 1]  902 	clr	(0x63, sp)
      000408 0F 64            [ 1]  903 	clr	(0x64, sp)
      00040A 0F 65            [ 1]  904 	clr	(0x65, sp)
      00040C 0F 66            [ 1]  905 	clr	(0x66, sp)
      00040E 0F 67            [ 1]  906 	clr	(0x67, sp)
      000410 0F 68            [ 1]  907 	clr	(0x68, sp)
      000412 0F 69            [ 1]  908 	clr	(0x69, sp)
      000414 0F 6A            [ 1]  909 	clr	(0x6a, sp)
      000416 0F 6B            [ 1]  910 	clr	(0x6b, sp)
      000418 0F 6C            [ 1]  911 	clr	(0x6c, sp)
      00041A 0F 6D            [ 1]  912 	clr	(0x6d, sp)
      00041C 0F 6E            [ 1]  913 	clr	(0x6e, sp)
      00041E 0F 6F            [ 1]  914 	clr	(0x6f, sp)
      000420 0F 70            [ 1]  915 	clr	(0x70, sp)
      000422 0F 71            [ 1]  916 	clr	(0x71, sp)
      000424 0F 72            [ 1]  917 	clr	(0x72, sp)
      000426 0F 73            [ 1]  918 	clr	(0x73, sp)
      000428 0F 74            [ 1]  919 	clr	(0x74, sp)
      00042A 0F 75            [ 1]  920 	clr	(0x75, sp)
      00042C 0F 76            [ 1]  921 	clr	(0x76, sp)
      00042E 0F 77            [ 1]  922 	clr	(0x77, sp)
      000430 0F 78            [ 1]  923 	clr	(0x78, sp)
      000432 0F 79            [ 1]  924 	clr	(0x79, sp)
      000434 0F 7A            [ 1]  925 	clr	(0x7a, sp)
      000436 0F 7B            [ 1]  926 	clr	(0x7b, sp)
      000438 0F 7C            [ 1]  927 	clr	(0x7c, sp)
      00043A 0F 7D            [ 1]  928 	clr	(0x7d, sp)
      00043C 0F 7E            [ 1]  929 	clr	(0x7e, sp)
      00043E 0F 7F            [ 1]  930 	clr	(0x7f, sp)
      000440 0F 80            [ 1]  931 	clr	(0x80, sp)
      000442 0F 81            [ 1]  932 	clr	(0x81, sp)
      000444 0F 82            [ 1]  933 	clr	(0x82, sp)
      000446 0F 83            [ 1]  934 	clr	(0x83, sp)
      000448 0F 84            [ 1]  935 	clr	(0x84, sp)
                                    936 ;	main.c: 18: buf[0] = 0xAF;
      00044A A6 AF            [ 1]  937 	ld	a, #0xaf
      00044C F7               [ 1]  938 	ld	(x), a
                                    939 ;	main.c: 19: buf[1] = 0x00;
      00044D 0F 02            [ 1]  940 	clr	(0x02, sp)
                                    941 ;	main.c: 20: buf[2] = 0xA6;
      00044F A6 A6            [ 1]  942 	ld	a, #0xa6
      000451 6B 03            [ 1]  943 	ld	(0x03, sp), a
                                    944 ;	main.c: 21: buf[3] = 0xA7;
      000453 A6 A7            [ 1]  945 	ld	a, #0xa7
      000455 6B 04            [ 1]  946 	ld	(0x04, sp), a
                                    947 ;	main.c: 22: buf[4] = 0xA8;
      000457 A6 A8            [ 1]  948 	ld	a, #0xa8
      000459 6B 05            [ 1]  949 	ld	(0x05, sp), a
                                    950 ;	main.c: 23: i2c_write(I2C_DISPLAY_ADDR,2,buf);
      00045B 89               [ 2]  951 	pushw	x
      00045C 4B 02            [ 1]  952 	push	#0x02
      00045E A6 3C            [ 1]  953 	ld	a, #0x3c
      000460 CDr02rC9         [ 4]  954 	call	_i2c_write
                                    955 ;	main.c: 30: i2c_read(I2C_DISPLAY_ADDR,12,buf1);
      000463 96               [ 1]  956 	ldw	x, sp
      000464 1C 00 06         [ 2]  957 	addw	x, #6
      000467 89               [ 2]  958 	pushw	x
      000468 4B 0C            [ 1]  959 	push	#0x0c
      00046A A6 3C            [ 1]  960 	ld	a, #0x3c
      00046C CDr02r56         [ 4]  961 	call	_i2c_read
                                    962 ;	main.c: 31: while(1);
      00046F                        963 00102$:
      00046F 20 FE            [ 2]  964 	jra	00102$
                                    965 ;	main.c: 32: }
      000471 5B 84            [ 2]  966 	addw	sp, #132
      000473 81               [ 4]  967 	ret
                                    968 	.area CODE
                                    969 	.area CONST
                                    970 	.area CONST
      000000                        971 ___str_0:
      000000 72 78 5F 62 75 66 5F   972 	.ascii "rx_buf_pointer"
             70 6F 69 6E 74 65 72
      00000E 0A                     973 	.db 0x0a
      00000F 00                     974 	.db 0x00
                                    975 	.area CODE
                                    976 	.area CONST
      000010                        977 ___str_1:
      000010 62 75 66 5F 70 6F 73   978 	.ascii "buf_pos"
      000017 0A                     979 	.db 0x0a
      000018 00                     980 	.db 0x00
                                    981 	.area CODE
                                    982 	.area CONST
      000019                        983 ___str_2:
      000019 62 75 66 5F 73 69 7A   984 	.ascii "buf_size"
             65
      000021 0A                     985 	.db 0x0a
      000022 00                     986 	.db 0x00
                                    987 	.area CODE
                                    988 	.area CONST
      000023                        989 ___str_3:
      000023 52 49 45 4E            990 	.ascii "RIEN"
      000027 0A                     991 	.db 0x0a
      000028 00                     992 	.db 0x00
                                    993 	.area CODE
                                    994 	.area INITIALIZER
      000000                        995 __xinit__I2C_IRQ:
      000000 00                     996 	.db #0x00	; 0
                                    997 	.area CABS (ABS)
